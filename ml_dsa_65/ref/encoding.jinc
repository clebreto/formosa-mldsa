require "parameters.jinc"

namespace error_polynomial {
    fn encode(reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] s1, reg ptr u8[ENCODED_ERROR_POLYNOMIAL_SIZE] dest)
        -> reg ptr u8[ENCODED_ERROR_POLYNOMIAL_SIZE]
    {
        inline int _eta;

        reg u32 lo hi;
        reg u32 coeff;

        reg u64 i addr;

        _eta = 4;
        ?{}, i = #set0_64();
        while (i < COEFFICIENTS_IN_POLYNOMIAL) {
            coeff = s1[(int) i];
            lo = _eta;
            lo -= coeff;

            coeff = s1[(int) i + 1];
            hi = _eta;
            hi -= coeff;

            hi <<= 4;
            hi |= lo;

            addr = i;
            addr >>= 1;
            dest[(int) addr] = hi;

            i += 2;
        }
        return dest;
    }
}

namespace s1 {
    inline
    fn encode(reg ptr u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] s1, reg ptr u8[S1_ENCODED_SIZE] dest)
        -> reg ptr u8[S1_ENCODED_SIZE]
    {
        inline int ii;
        reg ptr u8[ENCODED_ERROR_POLYNOMIAL_SIZE] buf;
        reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] poly;

        for ii = 0 to COLUMNS_IN_MATRIX_A {
            buf = dest[ENCODED_ERROR_POLYNOMIAL_SIZE * ii : ENCODED_ERROR_POLYNOMIAL_SIZE];
            poly = s1[COEFFICIENTS_IN_POLYNOMIAL * ii : COEFFICIENTS_IN_POLYNOMIAL];
            dest[ENCODED_ERROR_POLYNOMIAL_SIZE * ii : ENCODED_ERROR_POLYNOMIAL_SIZE] = error_polynomial::encode(poly, buf);
        }
        return dest;
    }
}

namespace s2 {
    inline
    fn encode(reg ptr u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] s1, reg ptr u8[S2_ENCODED_SIZE] dest)
        -> reg ptr u8[S2_ENCODED_SIZE]
    {
        inline int ii;
        reg ptr u8[ENCODED_ERROR_POLYNOMIAL_SIZE] buf;
        reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] poly;

        for ii = 0 to ROWS_IN_MATRIX_A {
            buf = dest[ENCODED_ERROR_POLYNOMIAL_SIZE * ii : ENCODED_ERROR_POLYNOMIAL_SIZE];
            poly = s1[COEFFICIENTS_IN_POLYNOMIAL * ii : COEFFICIENTS_IN_POLYNOMIAL];
            dest[ENCODED_ERROR_POLYNOMIAL_SIZE * ii : ENCODED_ERROR_POLYNOMIAL_SIZE] = error_polynomial::encode(poly, buf);
        }
        return dest;
    }
}

namespace t1 {
    fn encode_polynomial(reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] t1, reg ptr u8[T1_POLYNOMIAL_ENCODED_SIZE] buf)
        -> reg ptr u8[T1_POLYNOMIAL_ENCODED_SIZE]
    {
        reg u64 i;
        reg u64 addr;
        reg u32 x x1;
        reg u8 c;

        i = 0;
        while(i < COEFFICIENTS_IN_POLYNOMIAL / 4) {
            // buf[5*i+0] = t1[4*i+0] >> 0;

            addr = 4;
            addr *= i;
            x = t1[(int) addr];
            c = (8u) x;

            addr = 5;
            addr *= i;
            buf[(int) addr] = c;

            // buf[5*i+1] = (t1[4*i+0] >> 8) | (t1[4*i+1] << 2);

            addr = 4;
            addr *= i;
            x = t1[(int) addr];
            x >>= 8;

            addr = 4;
            addr *= i;
            addr += 1;
            x1 = t1[(int) addr];
            x1 <<= 2;
            x |= x1;

            addr = 5;
            addr *= i;
            addr += 1;
            c = (8u) x;
            buf[(int) addr] = c;

            // buf[5*i+2] = (t1[4*i+1] >> 6) | (t1[4*i+2] << 4);

            addr = 4;
            addr *= i;
            addr += 1;
            x = t1[(int) addr];
            x >>= 6;

            addr = 4;
            addr *= i;
            addr += 2;
            x1 = t1[(int) addr];
            x1 <<= 4;
            x |= x1;

            addr = 5;
            addr *= i;
            addr += 2;
            c = (8u) x;
            buf[(int) addr] = c;

            // buf[5*i+3] = (t1[4*i+2] >> 4) | (t1[4*i+3] << 6);

            addr = 4;
            addr *= i;
            addr += 2;
            x = t1[(int) addr];
            x >>= 4;

            addr = 4;
            addr *= i;
            addr += 3;
            x1 = t1[(int) addr];
            x1 <<= 6;
            x |= x1;

            addr = 5;
            addr *= i;
            addr += 3;
            c = (8u) x;
            buf[(int) addr] = c;

            // buf[5*i+4] = (t1[4*i+3] >> 2);

            addr = 4;
            addr *= i;
            addr += 3;
            x = t1[(int) addr];
            x >>= 2;

            addr = 5;
            addr *= i;
            addr += 4;
            c = (8u) x;
            buf[(int) addr] = c;

            i += 1;
        }

        return buf;
    }

    inline fn
    encode(reg ptr u8[T1_ENCODED_SIZE] encoded, reg ptr u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] t1) -> reg ptr u8[T1_ENCODED_SIZE] {
        reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] t1_to_pack;

        inline int j;

        for j = 0 to ROWS_IN_MATRIX_A {
            t1_to_pack = t1[COEFFICIENTS_IN_POLYNOMIAL * j : COEFFICIENTS_IN_POLYNOMIAL];
            encoded[j * T1_POLYNOMIAL_ENCODED_SIZE : T1_POLYNOMIAL_ENCODED_SIZE] = encode_polynomial(t1_to_pack, encoded[j * T1_POLYNOMIAL_ENCODED_SIZE : T1_POLYNOMIAL_ENCODED_SIZE]);
        }

        return encoded;
    }
}

namespace t0 {
    fn encode_polynomial(reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] t0, reg ptr u8[T0_POLYNOMIAL_ENCODED_SIZE] dest)
        -> reg ptr u8[T0_POLYNOMIAL_ENCODED_SIZE]
    {
        // TODO: This function needs some superficial optimization

        inline int max_t0;
        max_t0 = (1 << BITS_IN_LOWER_PART_OF_T) / 2;

        stack u32 t0_term;
        stack u32[8] t;

        reg u64 i j;
        reg u64 addr;

        reg u32 v32;

        reg u8 c c1;

        ?{}, i = #set0_64();
        while(i < COEFFICIENTS_IN_POLYNOMIAL / 8) {
            ?{}, j = #set0_64();
            while (j < 8) {
                addr = #LEA_64(8*i + j);
                v32 = t0[(int) addr];
                t0_term = v32;
                v32 = max_t0;
                v32 -= t0_term;
                t[(int) j] = v32;
                j += 1;
            }

            // Get ready.
            // Here be typos.
            // TODO: Check if there are indeed no typos

            //r[13*i+ 0]  =  t[0];

            v32 = t[0];
            c = (8u) v32;
            addr = i;
            addr *= 13;
            dest[(int) addr] = c;

            //r[13*i+ 1]  =  t[0] >>  8;
            //r[13*i+ 1] |=  t[1] <<  5;

            v32 = t[0];
            v32 >>= 8;
            c = (8u) v32;
            v32 = t[1];
            v32 <<= 5;
            c1 = (8u) v32;
            c |= c1;
            addr = i;
            addr *= 13;
            addr += 1;
            dest[(int) addr] = c;

            //r[13*i+ 2]  =  t[1] >>  3;

            v32 = t[1];
            v32 >>= 3;
            c = (8u) v32;
            addr = i;
            addr *= 13;
            addr += 2;
            dest[(int) addr] = c;

            //r[13*i+ 3]  =  t[1] >> 11;
            //r[13*i+ 3] |=  t[2] <<  2;

            v32 = t[1];
            v32 >>= 11;
            c = (8u) v32;
            v32 = t[2];
            v32 <<= 2;
            c1 = (8u) v32;
            c |= c1;
            addr = i;
            addr *= 13;
            addr += 3;
            dest[(int) addr] = c;

            //r[13*i+ 4]  =  t[2] >>  6;
            //r[13*i+ 4] |=  t[3] <<  7;

            v32 = t[2];
            v32 >>= 6;
            c = (8u) v32;
            v32 = t[3];
            v32 <<= 7;
            c1 = (8u) v32;
            c |= c1;
            addr = i;
            addr *= 13;
            addr += 4;
            dest[(int) addr] = c;

            //r[13*i+ 5]  =  t[3] >>  1;

            v32 = t[3];
            v32 >>= 1;
            c = (8u) v32;
            addr = i;
            addr *= 13;
            addr += 5;
            dest[(int) addr] = c;

            //r[13*i+ 6]  =  t[3] >>  9;
            //r[13*i+ 6] |=  t[4] <<  4;

            v32 = t[3];
            v32 >>= 9;
            c = (8u) v32;
            v32 = t[4];
            v32 <<= 4;
            c1 = (8u) v32;
            c |= c1;
            addr = i;
            addr *= 13;
            addr += 6;
            dest[(int) addr] = c;

            //r[13*i+ 7]  =  t[4] >>  4;

            v32 = t[4];
            v32 >>= 4;
            c = (8u) v32;
            addr = i;
            addr *= 13;
            addr += 7;
            dest[(int) addr] = c;

            //r[13*i+ 8]  =  t[4] >> 12;
            //r[13*i+ 8] |=  t[5] <<  1;

            v32 = t[4];
            v32 >>= 12;
            c = (8u) v32;
            v32 = t[5];
            v32 <<= 1;
            c1 = (8u) v32;
            c |= c1;
            addr = i;
            addr *= 13;
            addr += 8;
            dest[(int) addr] = c;

            //r[13*i+ 9]  =  t[5] >>  7;
            //r[13*i+ 9] |=  t[6] <<  6;

            v32 = t[5];
            v32 >>= 7;
            c = (8u) v32;
            v32 = t[6];
            v32 <<= 6;
            c1 = (8u) v32;
            c |= c1;
            addr = i;
            addr *= 13;
            addr += 9;
            dest[(int) addr] = c;

            //r[13*i+10]  =  t[6] >>  2;

            v32 = t[6];
            v32 >>= 2;
            c = (8u) v32;
            addr = i;
            addr *= 13;
            addr += 10;
            dest[(int) addr] = c;

            //r[13*i+11]  =  t[6] >> 10;
            //r[13*i+11] |=  t[7] <<  3;

            v32 = t[6];
            v32 >>= 10;
            c = (8u) v32;
            v32 = t[7];
            v32 <<= 3;
            c1 = (8u) v32;
            c |= c1;
            addr = i;
            addr *= 13;
            addr += 11;
            dest[(int) addr] = c;

            //r[13*i+12]  =  t[7] >>  5;

            v32 = t[7];
            v32 >>= 5;
            c = (8u) v32;
            addr = i;
            addr *= 13;
            addr += 12;
            dest[(int) addr] = c;

            i += 1;
        }


        return dest;
    }

    inline fn
    encode(reg ptr u8[T0_ENCODED_SIZE] encoded, reg ptr u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] t0) -> reg ptr u8[T0_ENCODED_SIZE] {
        reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] t0_to_pack;

        inline int j;

        for j = 0 to ROWS_IN_MATRIX_A {
            t0_to_pack = t0[COEFFICIENTS_IN_POLYNOMIAL * j : COEFFICIENTS_IN_POLYNOMIAL];
            encoded[j * T0_POLYNOMIAL_ENCODED_SIZE : T0_POLYNOMIAL_ENCODED_SIZE] = encode_polynomial(t0_to_pack, encoded[j * T0_POLYNOMIAL_ENCODED_SIZE : T0_POLYNOMIAL_ENCODED_SIZE]);
        }

        return encoded;
    }
}
