require "constants.jinc"
require "fips202.jinc"

inline
fn expandSEta4_poly(stack u8[64] rho_prime, reg u16 elem_idx, reg ptr u32[Li2_polydeg] poly)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 coeffs_generated;

	// SHA3 state
	stack u64[25] state;
	reg u64 offset;

	// temps
	reg u64 i;
	reg u8 c1 c2;
	reg u32 u32_c1;
	reg u32 v;
	reg u64 addr;
	
	reg u8 c;
	reg u32 c32;

	state = st0(state);

	?{}, i = #set0_64();
	while(i < 64) {
		c1 = rho_prime[(int) i];
		state[u8 (int) i] = c1;
		i += 1;
	}
	c = (8u) elem_idx;
	state[u8 64] = c;
	state[u8 65] = 0;
	state[u8 66] = 0x1F;
	state[u8 SHAKE256_RATE - 1] = 0x80;

	state = __keccakf1600_ref(state);
	?{}, coeffs_generated = #set0_64();
	?{}, offset = #set0_64();
	while (coeffs_generated < Li2_polydeg) {
		if(offset >= SHAKE256_RATE) {
			state = __keccakf1600_ref(state);
			?{}, offset = #set0_64();
		}

		c = state[u8 (int) offset];
		offset += 1;

		c32 = (32u) c;
		c32 &= 0x0F;
		if (c32 < 9) {
			v = 4;
			v -= c32;
			poly[(int) coeffs_generated] = v;
			coeffs_generated += 1;
		}

		if (coeffs_generated < Li2_polydeg) {
			c32 = (32u) c;
			c32 >>= 4;
			if(c32 < 9) {
				v = 4;
				v -= c32;
				poly[(int) coeffs_generated] = v;
				coeffs_generated += 1;
			}
		}
	}
	return poly;
}
inline
fn expandS_poly(stack u8[64] rho_prime, reg u16 elem_idx, reg ptr u32[Li2_polydeg] buf)
	-> reg ptr u32[Li2_polydeg] {
    buf = expandSEta4_poly(rho_prime, elem_idx, buf);
	return buf;
}

inline
fn expandS(stack u8[64] rho_prime)
	-> stack u32[Li2_l * Li2_polydeg], stack u32[Li2_k * Li2_polydeg]
{
	reg ptr u32[Li2_polydeg] entry;
	stack u32[Li2_l * Li2_polydeg] s1;
	stack u32[Li2_k * Li2_polydeg] s2;

	inline int i;

	for i = 0 to Li2_l {
		entry = s1[Li2_polydeg * i : Li2_polydeg];
		entry = expandS_poly(rho_prime, i, entry);
		s1[Li2_polydeg * i : Li2_polydeg] = entry;
	}

	for i = 0 to Li2_k {
		entry = s2[Li2_polydeg * i : Li2_polydeg];
		entry = expandS_poly(rho_prime, Li2_l + i, entry);
		s2[Li2_polydeg * i : Li2_polydeg] = entry;
	}

	return s1, s2;
}
