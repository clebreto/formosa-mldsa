require "parameters.jinc"

fn polyeta_4_pack(reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] s1, reg ptr u8[ENCODED_ERROR_POLYNOMIAL_SIZE] dest)
	-> reg ptr u8[ENCODED_ERROR_POLYNOMIAL_SIZE]
{
	inline int _eta;

	reg u32 lo hi;
	reg u32 coeff;

	reg u64 i addr;

	_eta = 4;
	?{}, i = #set0_64();
	while (i < COEFFICIENTS_IN_POLYNOMIAL) {
		coeff = s1[(int) i];
		lo = _eta;
		lo -= coeff;

		coeff = s1[(int) i + 1];
		hi = _eta;
		hi -= coeff;

		hi <<= 4;
		hi |= lo;

		addr = i;
		addr >>= 1;
		dest[(int) addr] = hi;

		i += 2;
	}
	return dest;
}

inline
fn pack_s1(reg ptr u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] s1, reg ptr u8[S1_ENCODED_SIZE] dest)
	-> reg ptr u8[S1_ENCODED_SIZE]
{
	inline int ii;
	reg ptr u8[ENCODED_ERROR_POLYNOMIAL_SIZE] buf;
	reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] poly;

	for ii = 0 to COLUMNS_IN_MATRIX_A {
		buf = dest[ENCODED_ERROR_POLYNOMIAL_SIZE * ii : ENCODED_ERROR_POLYNOMIAL_SIZE];
		poly = s1[COEFFICIENTS_IN_POLYNOMIAL * ii : COEFFICIENTS_IN_POLYNOMIAL];
		dest[ENCODED_ERROR_POLYNOMIAL_SIZE * ii : ENCODED_ERROR_POLYNOMIAL_SIZE] = polyeta_4_pack(poly, buf);
	}
	return dest;
}
inline
fn pack_s2(reg ptr u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] s1, reg ptr u8[S2_ENCODED_SIZE] dest)
	-> reg ptr u8[S2_ENCODED_SIZE]
{
	inline int ii;
	reg ptr u8[ENCODED_ERROR_POLYNOMIAL_SIZE] buf;
	reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] poly;

	for ii = 0 to ROWS_IN_MATRIX_A {
		buf = dest[ENCODED_ERROR_POLYNOMIAL_SIZE * ii : ENCODED_ERROR_POLYNOMIAL_SIZE];
		poly = s1[COEFFICIENTS_IN_POLYNOMIAL * ii : COEFFICIENTS_IN_POLYNOMIAL];
		dest[ENCODED_ERROR_POLYNOMIAL_SIZE * ii : ENCODED_ERROR_POLYNOMIAL_SIZE] = polyeta_4_pack(poly, buf);
	}
	return dest;
}

inline
fn rho_pack(reg ptr u8[32] in out)
	-> reg ptr u8[32]
{
	inline int i;
	reg u8 c;
	for i = 0 to 32 {
		c = in[i];
		out[i] = c;
	}
	return out;
}

fn polyt1_pack(reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] t1, reg ptr u8[T1_ENCODED_SIZE] buf)
	-> reg ptr u8[T1_ENCODED_SIZE]
{
	reg u64 i;
	reg u64 addr;
	reg u32 x x1;
	reg u8 c;

	i = 0;
	while(i < COEFFICIENTS_IN_POLYNOMIAL / 4) {
		// buf[5*i+0] = t1[4*i+0] >> 0;

		addr = 4;
		addr *= i;
		x = t1[(int) addr];
		c = (8u) x;

		addr = 5;
		addr *= i;
		buf[(int) addr] = c;

		// buf[5*i+1] = (t1[4*i+0] >> 8) | (t1[4*i+1] << 2);

		addr = 4;
		addr *= i;
		x = t1[(int) addr];
		x >>= 8;

		addr = 4;
		addr *= i;
		addr += 1;
		x1 = t1[(int) addr];
		x1 <<= 2;
		x |= x1;

		addr = 5;
		addr *= i;
		addr += 1;
		c = (8u) x;
		buf[(int) addr] = c;

		// buf[5*i+2] = (t1[4*i+1] >> 6) | (t1[4*i+2] << 4);

		addr = 4;
		addr *= i;
		addr += 1;
		x = t1[(int) addr];
		x >>= 6;

		addr = 4;
		addr *= i;
		addr += 2;
		x1 = t1[(int) addr];
		x1 <<= 4;
		x |= x1;

		addr = 5;
		addr *= i;
		addr += 2;
		c = (8u) x;
		buf[(int) addr] = c;

		// buf[5*i+3] = (t1[4*i+2] >> 4) | (t1[4*i+3] << 6);

		addr = 4;
		addr *= i;
		addr += 2;
		x = t1[(int) addr];
		x >>= 4;

		addr = 4;
		addr *= i;
		addr += 3;
		x1 = t1[(int) addr];
		x1 <<= 6;
		x |= x1;

		addr = 5;
		addr *= i;
		addr += 3;
		c = (8u) x;
		buf[(int) addr] = c;

		// buf[5*i+4] = (t1[4*i+3] >> 2);

		addr = 4;
		addr *= i;
		addr += 3;
		x = t1[(int) addr];
		x >>= 2;

		addr = 5;
		addr *= i;
		addr += 4;
		c = (8u) x;
		buf[(int) addr] = c;

		i += 1;
	}

	return buf;
}

fn polyt1_unpack(reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] t1, reg ptr u8[T1_ENCODED_SIZE] buf)
	-> reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL]
{
	reg u64 i i4 i5;
	reg u32 x0 x1 x2 x3;
	reg u32 xtmp1 xtmp2;

	i = 0;
	while (i < COEFFICIENTS_IN_POLYNOMIAL / 4) {
		// FIXME: opt: make i4 loop counter
		i4 = #LEA_64(4 * i); // i4 = 4 * i
		i5 = #LEA_64(4 * i + i); // i5 = 5 * i

		x0 = (32u)buf[(int) i5 + 0];
		xtmp1 = (32u)buf[(int) i5 + 1];
		xtmp2 = xtmp1;
		xtmp1 <<= 8;		
		x0 |= xtmp1;
		x0 &= 0x3FF;
		t1[(int) i4 + 0] = x0;

		x1 = xtmp2 >> 2;
		xtmp1 = (32u)buf[(int) i5 + 2];
		xtmp2 = xtmp1;
		xtmp1 <<= 6;
		x1 |= xtmp1;
		x1 &= 0x3FF;
		t1[(int) i4 + 1] = x1;
		
		x2 = xtmp2 >> 4;
		xtmp1 = (32u)buf[(int) i5 + 3];
		xtmp2 = xtmp1;
		xtmp1 <<= 4;
		x2 |= xtmp1;
		x2 &= 0x3FF;
		t1[(int) i4 + 2] = x2;

		x3 = xtmp2 >> 6;
		xtmp1 = (32u)buf[(int) i5 + 4];
		xtmp1 <<= 2;
		x3 |= xtmp1;
		x3 &= 0x3FF; // FIXME: opt: redundant operation
		t1[(int) i4 + 3] = x3;

		i += 1;
	}
	return t1;
}

fn polyt0_pack(reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] t0, reg ptr u8[T0_ENCODED_SIZE] dest)
	-> reg ptr u8[T0_ENCODED_SIZE]
{
	// TODO: This function needs some superficial optimization

	inline int max_t0;
	max_t0 = (1 << BITS_IN_LOWER_PART_OF_T) / 2;

	stack u32 t0_term;
	stack u32[8] t;
	
	reg u64 i j;
	reg u64 addr;

	reg u32 v32;

	reg u8 c c1;

	?{}, i = #set0_64();
	while(i < COEFFICIENTS_IN_POLYNOMIAL / 8) {
		?{}, j = #set0_64();
		while (j < 8) {
			addr = #LEA_64(8*i + j);
			v32 = t0[(int) addr];
			t0_term = v32;
			v32 = max_t0;
			v32 -= t0_term;
			t[(int) j] = v32;
			j += 1;
		}

		// Get ready.
		// Here be typos.
		// TODO: Check if there are indeed no typos

		//r[13*i+ 0]  =  t[0];

		v32 = t[0];
		c = (8u) v32;
		addr = i;
		addr *= 13;
		dest[(int) addr] = c;

		//r[13*i+ 1]  =  t[0] >>  8;
		//r[13*i+ 1] |=  t[1] <<  5;

		v32 = t[0];
		v32 >>= 8;
		c = (8u) v32;
		v32 = t[1];
		v32 <<= 5;
		c1 = (8u) v32;
		c |= c1;
		addr = i;
		addr *= 13;
		addr += 1;
		dest[(int) addr] = c;

		//r[13*i+ 2]  =  t[1] >>  3;

		v32 = t[1];
		v32 >>= 3;
		c = (8u) v32;
		addr = i;
		addr *= 13;
		addr += 2;
		dest[(int) addr] = c;

		//r[13*i+ 3]  =  t[1] >> 11;
		//r[13*i+ 3] |=  t[2] <<  2;

		v32 = t[1];
		v32 >>= 11;
		c = (8u) v32;
		v32 = t[2];
		v32 <<= 2;
		c1 = (8u) v32;
		c |= c1;
		addr = i;
		addr *= 13;
		addr += 3;
		dest[(int) addr] = c;

		//r[13*i+ 4]  =  t[2] >>  6;
		//r[13*i+ 4] |=  t[3] <<  7;

		v32 = t[2];
		v32 >>= 6;
		c = (8u) v32;
		v32 = t[3];
		v32 <<= 7;
		c1 = (8u) v32;
		c |= c1;
		addr = i;
		addr *= 13;
		addr += 4;
		dest[(int) addr] = c;

		//r[13*i+ 5]  =  t[3] >>  1;

		v32 = t[3];
		v32 >>= 1;
		c = (8u) v32;
		addr = i;
		addr *= 13;
		addr += 5;
		dest[(int) addr] = c;

		//r[13*i+ 6]  =  t[3] >>  9;
		//r[13*i+ 6] |=  t[4] <<  4;

		v32 = t[3];
		v32 >>= 9;
		c = (8u) v32;
		v32 = t[4];
		v32 <<= 4;
		c1 = (8u) v32;
		c |= c1;
		addr = i;
		addr *= 13;
		addr += 6;
		dest[(int) addr] = c;

		//r[13*i+ 7]  =  t[4] >>  4;

		v32 = t[4];
		v32 >>= 4;
		c = (8u) v32;
		addr = i;
		addr *= 13;
		addr += 7;
		dest[(int) addr] = c;

		//r[13*i+ 8]  =  t[4] >> 12;
		//r[13*i+ 8] |=  t[5] <<  1;

		v32 = t[4];
		v32 >>= 12;
		c = (8u) v32;
		v32 = t[5];
		v32 <<= 1;
		c1 = (8u) v32;
		c |= c1;
		addr = i;
		addr *= 13;
		addr += 8;
		dest[(int) addr] = c;

		//r[13*i+ 9]  =  t[5] >>  7;
		//r[13*i+ 9] |=  t[6] <<  6;

		v32 = t[5];
		v32 >>= 7;
		c = (8u) v32;
		v32 = t[6];
		v32 <<= 6;
		c1 = (8u) v32;
		c |= c1;
		addr = i;
		addr *= 13;
		addr += 9;
		dest[(int) addr] = c;

		//r[13*i+10]  =  t[6] >>  2;

		v32 = t[6];
		v32 >>= 2;
		c = (8u) v32;
		addr = i;
		addr *= 13;
		addr += 10;
		dest[(int) addr] = c;

		//r[13*i+11]  =  t[6] >> 10;
		//r[13*i+11] |=  t[7] <<  3;

		v32 = t[6];
		v32 >>= 10;
		c = (8u) v32;
		v32 = t[7];
		v32 <<= 3;
		c1 = (8u) v32;
		c |= c1;
		addr = i;
		addr *= 13;
		addr += 11;
		dest[(int) addr] = c;

		//r[13*i+12]  =  t[7] >>  5;

		v32 = t[7];
		v32 >>= 5;
		c = (8u) v32;
		addr = i;
		addr *= 13;
		addr += 12;
		dest[(int) addr] = c;

		i += 1;
	}


	return dest;
}
