require "fips202.jinc"
require "parameters.jinc"
require "encoding/gamma1.jinc"

inline
fn xof_init(stack u64[25] state, reg ptr u8[64] rho_prime, stack u16 kappa)
    -> stack u64[25] {
    reg u64 i;
    reg u8 c;
    reg u16 v;

    state = st0(state);
    i = 0;
    while(i < 64) {
        c = rho_prime[(int) i];
        state[u8 (int) i] = c;
        i += 1;
    }

    v = kappa;
    v &= 0xFF;
    c = (8u) v;
    state[u8 64] = c;

    v = kappa;
    v >>= 8;
    c = (8u) v;
    state[u8 65] = c;

    state[u8 66] ^= 0x1f;
    state[u8 SHAKE256_RATE - 1] ^= 0x80;

    return state;
}

inline
fn sample_mask_polynomial(reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] f, reg ptr u8[64] rho_prime, stack u16 kappa)
    -> reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL]
{
    reg u64 i;
    reg u8 c;
    stack u64[25] state;
    stack u8[(ENCODED_GAMMA1_POLYNOMIAL_SIZE / SHAKE256_RATE) * SHAKE256_RATE + SHAKE256_RATE] mask_polynomial_encoded;
    stack u64 y_loc;
    stack u64 output_squeeze_counter;
    reg u64 addr;

    state = xof_init(state, rho_prime, kappa);

    y_loc = 0;
    output_squeeze_counter = 0;
    while(output_squeeze_counter < (ENCODED_GAMMA1_POLYNOMIAL_SIZE / SHAKE256_RATE + 1)) {
        state = __keccakf1600_ref(state);

        i = 0;
        while(i < SHAKE256_RATE) {
            addr = i;
            c = state[u8 (int) addr];
            addr = y_loc;
            mask_polynomial_encoded[(int) addr] = c;
            y_loc += 1;
            i += 1;
        }

        output_squeeze_counter += 1;
    }

    f = gamma1::decode(f, mask_polynomial_encoded[0 : ENCODED_GAMMA1_POLYNOMIAL_SIZE]);

    return f;
}

inline
fn sample_mask_vector(reg ptr u8[64] rho_prime, reg u16 nonce)
    -> stack u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL]
{
    stack u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] mask_vector;
    reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] mask_polynomial;

    inline int i;
    stack u16 kappa;
    reg u16 v;

    for i = 0 to COLUMNS_IN_MATRIX_A {
        v = nonce;
        v += i;
        kappa = v;

        mask_polynomial = mask_vector[COEFFICIENTS_IN_POLYNOMIAL * i : COEFFICIENTS_IN_POLYNOMIAL];
        mask_polynomial = sample_mask_polynomial(mask_polynomial, rho_prime, kappa);

        mask_vector[COEFFICIENTS_IN_POLYNOMIAL * i : COEFFICIENTS_IN_POLYNOMIAL] = mask_polynomial;
    }
    return mask_vector;
}
