require "fips202.jinc"
require "hashing.jinc"
require "constants.jinc"
require "parameters.jinc"
require "encoding/s1.jinc"
require "encoding/s2.jinc"
require "encoding/t0.jinc"
require "encoding/signature.jinc"
require "encoding/commitment.jinc"
require "row_vector.jinc"
require "sample_mask_vector.jinc"

inline
fn compute_rho_prime(reg ptr u8[32] k, reg ptr u8[32] randomness, reg ptr u8[MESSAGE_REPRESENTATIVE_SIZE] mu)
    -> stack u8[MESSAGE_REPRESENTATIVE_SIZE]
{
    stack u8[64] rho_prime;
    reg u8 c;
    reg u64 i;
    stack u64[25] state;
    reg u64 loc;

    state = st0(state);
    ?{}, i = #set0_64();
    while(i < 32) {
        c = k[(int) i];
        state[u8 (int) i] = c;
        i += 1;
    }
    while(i < 64) {
        loc = i;
        loc -= 32;
        c = randomness[(int) loc];
        state[u8 (int) i] = c;  
        i += 1;
    }
    while(i < 128) {
        loc = i;
        loc -= MESSAGE_REPRESENTATIVE_SIZE;
        c = mu[(int) loc];
        state[u8 (int) i] = c;
        i += 1;
    }

    state[u8 128] ^= 0x1f;
    state[u8 SHAKE256_RATE - 1] ^= 0x80;

    state = __keccakf1600_ref(state);

    ?{}, i = #set0_64();
    while(i < 64) {
        c = state[u8 (int) i];
        rho_prime[(int) i] = c;
        i += 1;
    }
    return rho_prime;
}

inline
fn sign_internal(
        reg ptr u8[SIGNING_KEY_SIZE] signing_key,
        reg u64 pointer_to_message,
        reg u64 message_size,
        reg ptr u8[32] randomness
)
        -> stack u8[SIGNATURE_SIZE], stack u32
{
    stack u8[SIGNATURE_SIZE] signature;

    // parts of signing_key
    stack u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] s1;
    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] s2;
    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] t0;

    // automatic variables in spec
    stack u32[ROWS_IN_MATRIX_A * COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] matrix_A;
    stack u8[MESSAGE_REPRESENTATIVE_SIZE] mu;

    // corresponds to kappa/l in spec
    stack u16 nonce;
    reg u16 reg_nonce;
    stack u8[64] rho_prime;

    stack u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] z;
    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] h;

    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] w0 w1;
    stack u8[ENCODED_COMMITMENT_SIZE] commitment_encoded;
    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] r0;

    stack u8[COMMITMENT_HASH_SIZE] commitment_hash;

    stack u32[COEFFICIENTS_IN_POLYNOMIAL] verifier_challenge;

    // while loop condition
    stack u8 done;
    // attempt: abort with error if we have tried too many times
    stack u16 attempt;
    // return status: ok == 0, err == -1
    stack u32 status;
    // temporary bools used for while loop condition
    reg bool tmpbool;
    reg bool zf;
    reg u8 tmpboolu8;

    // extra intermediate values
    // not space-efficient...
    // but this is reference impl so we're fine?
    stack u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] y;
    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] w;
    stack u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] y_as_ntt;
    stack u32[COLUMNS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] cs1;
    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] cs2;
    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] ct0;
    stack u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL] r0_plus_ct0;

    stack u32 ones_in_hint;
    stack u8 normcheck_result;

    s1 = s1::decode(signing_key[START_OF_S1_IN_ENCODED_SIGNING_KEY: S1_ENCODED_SIZE], s1);
    s2 = s2::decode(signing_key[START_OF_S2_IN_ENCODED_SIGNING_KEY: S2_ENCODED_SIZE], s2);
    t0 = t0::decode(t0, signing_key[START_OF_T0_IN_ENCODED_SIGNING_KEY: T0_ENCODED_SIZE]);

    () = #spill(randomness);
    mu = hash_tr_m(signing_key[64:MESSAGE_REPRESENTATIVE_SIZE], message_size, pointer_to_message);
    () = #unspill(randomness);

    rho_prime = compute_rho_prime(signing_key[32:32], randomness, mu);

    matrix_A = expandA(signing_key[0:32]);

    s1 = row_vector::ntt(s1);
    s2 = column_vector::ntt(s2);
    t0 = column_vector::ntt(t0);

    nonce = 0;
    done = 0;
    attempt = 1;
    status = -1;
    while {
        // TODO: Error if we exhaust the number of attempts.
        tmpbool = attempt > MAX_SIGNING_ATTEMPTS;
        tmpboolu8 = #SETcc(tmpbool);
        tmpboolu8 |= done;
        _, _, _, _, zf = #TEST_8(tmpboolu8, tmpboolu8);
    } (zf) {
        attempt += 1;

        reg_nonce = nonce;
        y = sample_mask_vector(rho_prime, reg_nonce);
        nonce += COLUMNS_IN_MATRIX_A;

        y_as_ntt = #copy(y);
        y_as_ntt = row_vector::ntt(y_as_ntt);
        w = row_vector::multiply_with_matrix_on_the_left(matrix_A, y_as_ntt);
        w = column_vector::reduce32(w);
        w = column_vector::invert_ntt_montgomery(w);

        w = column_vector::conditionally_add_modulus(w);
        w0, w1 = column_vector::decompose(w);

        commitment_encoded = commitment::encode(w1);

        commitment_hash = hash_mu_w1(mu, commitment_encoded);

        verifier_challenge = sample_in_ball(verifier_challenge, commitment_hash);
        verifier_challenge = polynomial::ntt(verifier_challenge);

        cs1 = row_vector::multiply_by_polynomial(s1, verifier_challenge);
        cs1 = row_vector::invert_ntt_montgomery(cs1);
        z = row_vector::add(cs1, y);
        z = row_vector::reduce32(z);
        normcheck_result = row_vector::check_infinity_norm(z, (int) (GAMMA1 - BETA));

        if(normcheck_result == 0) {
            cs2 = column_vector::multiply_by_polynomial(s2, verifier_challenge);
            cs2 = column_vector::invert_ntt_montgomery(cs2);
            r0 = column_vector::subtract(w0, cs2);
            w0 = column_vector::reduce32(w0);
            normcheck_result = column_vector::check_infinity_norm(r0, (int) (GAMMA2 - BETA));

            if(normcheck_result == 0) {
                ct0 = column_vector::multiply_by_polynomial(t0, verifier_challenge);
                ct0 = column_vector::invert_ntt_montgomery(ct0);
                ct0 = column_vector::reduce32(ct0);
                normcheck_result = column_vector::check_infinity_norm(ct0, GAMMA2);

                if(normcheck_result == 0) {
                    r0_plus_ct0 = column_vector::add(r0, ct0);

                    ones_in_hint, h = column_vector::make_hint(r0_plus_ct0, w1);
                    if(ones_in_hint < MAX_ONES_IN_HINT) {
                        done = 1;
                        status = 0;
                    }
                }
            }
        }
    }

    signature = signature::encode(commitment_hash, z, h);
    return signature, status;
}
