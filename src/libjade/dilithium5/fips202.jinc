require "../../../ext/libjade/src/common/keccak/keccak1600/armv7m/ref/keccakf1600.jinc"
require "params.jinc"


inline fn __keccak_init_ref(reg ptr u32[25*2] state) -> reg ptr u32[25*2]
{
  reg u32 i t;

  i = 0;
  t = 0;
  while(i < 25*2)
  { state[(int)i] = t;
    i += 1;
  }

  return state;
}


inline fn __add_seed_ref(reg ptr u32[25*2] state,
                         reg ptr u8[SEEDBYTES] in) 
                      -> reg ptr u32[25*2] 
{
  reg u32 i t0 t1 inlen4;

  inlen4 = SEEDBYTES >> 2;

  i = 0;
  while ( i < inlen4 )
  {
    t0 = in[u32 (int)i];
    t1 = state[(int)i];
    t0 ^= t1;
    state[(int)i] = t0;
    i += 1;
  }
  return state;
}


inline fn __add_nonce_ref(
  reg ptr u32[25*2] state, 
  inline int i, 
  reg u32 nonce) 
-> reg ptr u32[25*2] 
{
  reg u32 t0 t1;
  t1 = (32u) state[u16 (int)i];
  t0 = nonce ^ t1;
  state[u16 (int)i] = t0;
  return state;
}


param int TRAIL_BYTE = 0x1f;

inline fn __add_block_end(
   reg ptr u32[25*2] state, 
   inline int i, 
   inline int rate
) -> reg ptr u32[25*2]
{
  reg u32 t0 t1;
  
  t0 = (32u) state[u8 (int)i];
  t0 ^= TRAIL_BYTE;
  state[u8 (int)i] = (8u) t0;

  rate -= 1;

  t0 = (32u) state[u8 rate];
  t1 = 0x80;
  t0 ^= t1;
  state[u8 rate] = (8u) t0;

  return state;
}


inline fn __SHAKE256_add_final_block_ref(
  reg ptr u32[25*2] state,
  reg ptr u8[SEEDBYTES] in
) -> reg ptr u32[25*2]
{
  state = __add_seed_ref(state, in);
  state = __add_block_end(state, SEEDBYTES, SHAKE256_RATE);
  return state;
}


inline fn __SHAKE256_xtr_bytes_ref(
  reg ptr u32[25*2] state,
  reg ptr u8[SHAKE256_RATE] out
) -> reg ptr u8[SHAKE256_RATE]
{
  reg u32 i t ;

  inline int outlen4;
  outlen4 = SHAKE256_RATE >> 2;

  i = 0;
  while ( i < outlen4 )
  {
    t = state[(int)i];
    out[u32 (int)i] = t;
    i += 1;
  }

  return out;
}

inline fn __SHAKE128_xtr_bytes_ref(
  reg ptr u32[25*2] state,
  reg ptr u8[SHAKE128_RATE] out
) -> reg ptr u8[SHAKE128_RATE]
{
  reg u32 i t ;

  inline int outlen4;
  outlen4 = SHAKE128_RATE >> 2;

  i = 0;
  while ( i < outlen4 )
  {
    t = state[(int)i];
    out[u32 (int)i] = t;
    i += 1;
  }

  return out;
}

// obs: @pre: inlen < rate_in_bytes
/*
inline fn __add_final_block_ref_BG(
  reg ptr u32[PQC_SHAKECTX_BYTES*2] state,
  reg ptr u8[SEEDBYTES] in,
  reg     u32 rate
) -> reg ptr u32[25*2]
{
  reg u32 i t0 t1 inlen4;

  inlen4 = SEEDBYTES >> 2;

  i = 0;
  while ( i < inlen4 )
  {
    t0 = in[u32 (int)i];
    t1 = state[(int)i];
    t0 ^= t1;
    state[(int)i] = t0;
    i += 1;
  }

  i <<= 2;
  while ( i < SEEDBYTES )
  {
    t0 = (32u)in[(int) i];
    t1 = (32u) state[u8 (int)i];
    t0 ^= t1;
    state[u8 (int)i] = (8u) t0;
    i += 1;
  }

  t0 = (32u) state[u8 (int)i];
  t0 ^= TRAIL_BYTE;
  state[u8 (int)i] = (8u) t0;

  i = rate;
  i -= 1;

  t0 = (32u) state[u8 (int)i];
  t1 = 0x80;
  t0 ^= t1;
  state[u8 (int)i] = (8u) t0;

  return state;
}
*/


fn __SHAKE128_stream_init
  (reg ptr u32[25*2] state, 
   reg ptr u8[SEEDBYTES] seed, 
   reg u32 nonce
) -> reg ptr u32[25*2] 
{
  state = __keccak_init_ref(state);
  state = __add_seed_ref(state, seed);
  state = __add_nonce_ref(state, SEEDBYTES, nonce);
  state = __add_block_end(state, SEEDBYTES + 2, SHAKE128_RATE);
  state = _keccakf1600_ref(state);
  return state;
}  

/*
fn _poly_uniform(reg ptr u32[N] a,
                 reg ptr u8[SEEDBYTES] seed;
                 reg u32 nonce) -> reg ptr u32[N]
{
 
*/ 
   










