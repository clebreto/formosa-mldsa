require "polyvec.jinc"

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_pack_pk
*
* Description: Bit-pack public key pk = (rho, t1).
*
* Arguments:   - uint8_t pk[]: output byte array
*              - const uint8_t rho[]: byte array containing rho
*              - const polyveck *t1: pointer to vector t1
**************************************************/
fn _pack_pk(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[SEEDBYTES] rho, reg ptr u32[polyveck] t1) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] {
    pk = pk; rho = rho; t1 = t1;

    inline int i;

    reg ptr u8[SEEDBYTES] tpk;
    tpk = pk[0:SEEDBYTES];
    tpk = #copy(rho);
    pk[0:SEEDBYTES] = tpk;

    reg ptr u8[POLYT1_PACKEDBYTES] npk;
    reg ptr u32[N] nt1;
    for i = 0 to K {
        nt1 = t1[i * N: N];
        npk = pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES];
        pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES] = _polyt1_pack(npk, nt1);
    }

    return pk;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_pack_sk
*
* Description: Bit-pack secret key sk = (rho, tr, key, t0, s1, s2).
*
* Arguments:   - uint8_t sk[]: output byte array
*              - const uint8_t rho[]: byte array containing rho
*              - const uint8_t tr[]: byte array containing tr
*              - const uint8_t key[]: byte array containing key
*              - const polyveck *t0: pointer to vector t0
*              - const polyvecl *s1: pointer to vector s1
*              - const polyveck *s2: pointer to vector s2
**************************************************/
fn _pack_sk(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk, reg ptr u8[SEEDBYTES] rho, reg ptr u8[SEEDBYTES] tr, reg ptr u8[SEEDBYTES] key, reg ptr u32[polyveck] t0, reg ptr u32[polyvecl] s1, reg ptr u32[polyveck] s2) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] {
    sk = sk; rho = rho; tr = tr; key = key; t0 = t0; s1 = s1; s2 = s2;

    inline int i;
    inline int start_pos;
    start_pos = 0;
    
    reg ptr u8[SEEDBYTES] tsk;
    
    tsk = sk[0:SEEDBYTES];
    tsk = #copy(rho);
    sk[start_pos:SEEDBYTES] = tsk;
    start_pos += SEEDBYTES;
    
    tsk = sk[SEEDBYTES :  SEEDBYTES];
    tsk = #copy(key);
    sk[start_pos : SEEDBYTES] = tsk;
    start_pos += SEEDBYTES;
    
    tsk = sk[2 * SEEDBYTES : SEEDBYTES];
    tsk = #copy(tr);
    sk[start_pos : SEEDBYTES] = tsk;
    start_pos += SEEDBYTES;
    
    reg ptr u8[POLYETA_PACKEDBYTES] nsk;

    () = #spill(t0);
    () = #spill(s2);
    reg ptr u32[N] ns1;
    for i = 0 to L {
        ns1 = s1[i * N: N];
	() = #spill(s1);	
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
        sk[start_pos : POLYETA_PACKEDBYTES] = _polyeta_pack(nsk, ns1);
	() = #unspill(s1);
	start_pos += POLYETA_PACKEDBYTES;
    }
    
    () = #unspill(s2);
    reg ptr u32[N] ns2;
    for i = 0 to K {
        ns2 = s2[i * N: N];
	() = #spill(s2);	
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
        sk[start_pos : POLYETA_PACKEDBYTES] = _polyeta_pack(nsk, ns2);
        () = #unspill(s2);
	start_pos += POLYETA_PACKEDBYTES;
    }
    () = #unspill(t0);
    
    reg ptr u32[N] nt0;
    reg ptr u8[POLYT0_PACKEDBYTES] nnsk;
    for i = 0 to K {
        nt0 = t0[i * N: N];
        nnsk = sk[start_pos : POLYT0_PACKEDBYTES];
	() = #spill(t0);
        sk[start_pos : POLYT0_PACKEDBYTES] = _polyt0_pack(nnsk, nt0);
	() = #unspill(t0);
	start_pos += POLYT0_PACKEDBYTES;	
    }
    
    return sk;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_pack_sig
*
* Description: Bit-pack signature sig = (c, z, h).
*
* Arguments:   - uint8_t sig[]: output byte array
*              - const uint8_t *c: pointer to PQCLEAN_DILITHIUM5_CLEAN_challenge hash length SEEDBYTES
*              - const polyvecl *z: pointer to vector z
*              - const polyveck *h: pointer to hint vector h
**************************************************/
fn _pack_sig(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, reg ptr u8[SEEDBYTES] c, reg ptr u32[polyvecl] z, reg ptr u32[polyveck] h) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] {
    sig = sig; c = c; z = z; h = h;
    //TODO
    return sig; 
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_unpack_pk
*
* Description: Unpack public key pk = (rho, t1).
*
* Arguments:   - const uint8_t rho[]: output byte array for rho
*              - const polyveck *t1: pointer to output vector t1
*              - uint8_t pk[]: byte array containing bit-packed pk
**************************************************/
fn _unpack_pk(reg ptr u8[SEEDBYTES] rho, reg ptr u32[polyveck] t1, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk) -> reg ptr u8[SEEDBYTES], reg ptr u32[polyveck] {
    pk = pk; rho = rho; t1 = t1;
    
    inline int i;

    reg ptr u8[SEEDBYTES] tpk;
    tpk = pk[0 : SEEDBYTES];
    rho = #copy(tpk);
    
    reg ptr u8[POLYT1_PACKEDBYTES] npk;
    reg ptr u32[N] nt1;
    for i = 0 to K {
        nt1 = t1[i * N: N];
        npk = pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES];    
        t1[i * N : N] = _polyt1_unpack(nt1, npk);
    }
    
    return rho, t1;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_unpack_sk
*
* Description: Unpack secret key sk = (rho, tr, key, t0, s1, s2).
*
* Arguments:   - const uint8_t rho[]: output byte array for rho
*              - const uint8_t tr[]: output byte array for tr
*              - const uint8_t key[]: output byte array for key
*              - const polyveck *t0: pointer to output vector t0
*              - const polyvecl *s1: pointer to output vector s1
*              - const polyveck *s2: pointer to output vector s2
*              - uint8_t sk[]: byte array containing bit-packed sk
**************************************************/
fn _unpack_sk(reg ptr u8[SEEDBYTES] rho, reg ptr u8[SEEDBYTES] tr, reg ptr u8[SEEDBYTES] key, reg ptr u32[polyveck] pt0, reg ptr u32[polyvecl] ps1, reg ptr u32[polyveck] ps2, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[SEEDBYTES], reg ptr u8[SEEDBYTES], reg ptr u8[SEEDBYTES], reg ptr u32[polyveck], reg ptr u32[polyvecl], reg ptr u32[polyveck] {
    sk = sk; rho = rho; tr = tr; key = key; pt0 = pt0; ps1 = ps1; ps2 = ps2;

    return rho, tr, key, pt0, ps1, ps2;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_unpack_sig
*
* Description: Unpack signature sig = (c, z, h).
*
* Arguments:   - uint8_t *c: pointer to output PQCLEAN_DILITHIUM5_CLEAN_challenge hash
*              - polyvecl *z: pointer to output vector z
*              - polyveck *h: pointer to output hint vector h
*              - const uint8_t sig[]: byte array containing
*                bit-packed signature
*
* Returns 1 in case of malformed signature; otherwise 0.
**************************************************/
fn _unpack_sig(reg ptr u8[SEEDBYTES] c, reg ptr u32[polyvecl] z, reg ptr u32[polyveck] h, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig) -> reg ptr u8[SEEDBYTES], reg ptr u32[polyvecl], reg ptr u32[polyveck] {
    sig = sig; c = c; z = z; h = h;
    //TODO
    return c, z, h;
}