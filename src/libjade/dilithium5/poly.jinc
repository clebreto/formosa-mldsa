require "params.jinc"
require "rounding.jinc"
require "reduce.jinc"
require "ntt.jinc"

require "map.jinc"
require "fips202.jinc"



inline fn high(reg u32[2] x) -> reg u32
{
    reg u32 h;
    h = x[1];
    return h;
}

inline fn low(reg u32[2] x) -> reg u32
{
    reg u32 l;
    l = x[0];
    return l;
}

inline fn make_64(reg u32 h, reg u32 l) -> reg u32[2]
{
    reg u32[2] y;

    y[0] = l;
    y[1] = h;

    return y;
}

inline fn shift_left(reg u32[2] x, inline int i) -> reg u32[2]
{
    reg u32 h l;
    h = high(x);
    l = low(x);

    h <<= i;
    h |= (l >> (32 - i));
    l <<= i;

    reg u32[2] y;
    y = make_64(h, l);

    return y;
}

inline fn shift_right(reg u32[2] x, inline int i) -> reg u32[2]
{
    reg u32 h l;
    h = high(x);
    l = low(x);

    l >>= i;
    l |= (h << (32 - i));
    h >>= i;

    reg u32[2] y;
    y = make_64(h, l);

    return y;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_reduce
*
* Description: Inplace reduction of all coefficients of polynomial to
*              representative in [-6283009,6283007].
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __map1__reduce32_8380417(a);
  return a;
}

fn _poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N] {
   a = __poly_reduce(a);
   return a; 
}


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_caddq
*
* Description: For all coefficients of in/out polynomial add Q if
*              coefficient is negative.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/

inline fn __poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __map1__caddq(a);
  return a;
}

fn _poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __poly_caddq(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_add
*
* Description: Add polynomials. No modular reduction is performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first summand
*              - const poly *b: pointer to second summand
**************************************************/

inline fn __poly_add_body(reg u32 coeff_a, reg u32 coeff_b) -> reg u32
{
  coeff_a = coeff_a + coeff_b;
  return coeff_a;
}

inline fn __poly_add(reg ptr u32[N] r a b) -> reg ptr u32[N]
{
  reg u32 i coeff_r coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_r = __poly_add_body(coeff_a, coeff_b);
    r[(int) i] = coeff_r;

    i += 1;
  }

  return r;
}

fn _poly_add(reg ptr u32[N] r a b) -> reg ptr u32[N] {
  r = __poly_add(r, a, b);
  return r;
} 

inline fn __poly_add_inplace(reg ptr u32[N] a b) -> reg ptr u32[N]
{
  reg u32 i coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_a = __poly_add_body(coeff_a, coeff_b);
    a[(int) i] = coeff_a;

    i += 1;
  }

  return a;
}

fn _poly_add_inplace(reg ptr u32[N] a b) -> reg ptr u32[N] {
  a = __poly_add_inplace(a, b);
  return a;
} 

fn _poly_add2_inplace(reg ptr u32[N] a) -> reg ptr u32[N]
{
  reg u32 i coeff_a;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_a = __poly_add_body(coeff_a, coeff_a);
    a[(int) i] = coeff_a;

    i += 1;
  }

  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_chknorm
*
* Description: Check infinity norm of polynomial against given bound.
*              Assumes input coefficients were reduced by PQCLEAN_DILITHIUM5_CLEAN_reduce32().
*
* Arguments:   - const poly *a: pointer to polynomial
*              - int32_t B: norm bound
*
* Returns 0 if norm is strictly smaller than B <= (Q-1)/8 and 1 otherwise.
**************************************************/

inline fn __poly_chknorm(reg ptr u32[N] a, reg u32 B) -> reg u32 {
  reg u32 r;
  reg u32 q;
  r = 0;
  q = __Q();
  q -= 1;
  q = q >> 3;
  
  if (B >s q) {
    r = 1;
  }

  reg u32 t;
  
  reg u32 i;
  i = 0;
  while {
    t = a[(int) i];
    t = -t if t <s 0;
    
    i += 1;

    if (t >=s B) {
      r = 1;
      i = N;
    }
    
  } (i != N)
  
  return r;  
}

fn _poly_chknorm(reg ptr u32[N] a, reg u32 B) -> reg u32 {
  reg u32 r;
  r = __poly_chknorm(a, B);
  return r;
}

/**************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_challenge
*
* Description: Implementation of H. Samples polynomial with TAU nonzero
*              coefficients in {-1,1} using the output stream of
*              SHAKE256(seed).
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const uint8_t mu[]: byte array containing seed of length SEEDBYTES
**************************************************/

fn _poly_challenge(reg ptr u32[N] c, reg ptr u8[SEEDBYTES] seed) -> reg ptr u32[N]
{
  stack u32[PQC_SHAKECTX_BYTES*2] _state;
  reg ptr u32[PQC_SHAKECTX_BYTES*2] state;

  stack ptr u32[N] cs;

  cs = c; 
  state = _state;

  // equivalent to shake256_inc_init_jazz(state);
  // equivalent to shake256_inc_absorb_jazz(state, seed, SEEDBYTES) and shake256_inc_finalize_jazz(state)
  state = __SHAKE256_init_seed_ref(state, seed);
  c = cs;


  reg u32[2] signs;
  stack u32[2] s_signs;
  stack u32 js;

  reg u32 aux, pos, i; 
  signs[0] = state[u32 0];
  signs[1] = state[u32 1];

  pos = 8;

  aux = 0;
  // FIXME improve this loop
  i = 0;
  while (i < N) {
    c[(int) i] = aux;
    i += 1;
  }

  reg u32 j;
  j = N - TAU;
  reg u32 b;
  while (j < N) {
    while {
      if (pos >= SHAKE256_RATE) {
          // save j pbuf c, signs
          js = j; cs = c; s_signs = #copy(signs); 
          state = _keccakf1600_ref(state);  
          j = js; c = cs;  signs = #copy(s_signs);
          pos = 0;
      }

      b = (32u) state[u8 (int) pos];
      pos += 1;
    } (b > j)

    aux = c[(int) b];
    c[(int) j] = aux;

    aux = signs[0] & 1;
    aux <<= 1;
    aux = 1 - aux;
    c[(int) b] = aux;

    signs = shift_right(signs, 1);

    j += 1;
  }

  return c;
}

/*************************************************                                                         
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_decompose                                                     
*                                                                                                          
* Description: For all coefficients c of the input polynomial,                                             
*              compute high and low bits c0, c1 such c mod Q = c1*ALPHA + c0                               
*              with -ALPHA/2 < c0 <= ALPHA/2 except c1 = (Q-1)/ALPHA where we                              
*              set c1 = 0 and -ALPHA/2 <= c0 = c mod Q - Q < 0.                                            
*              Assumes coefficients to be standard representatives.                                        
*                                                                                                          
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1                               
*              - poly *a0: pointer to output polynomial with coefficients c0                               
*              - const poly *a: pointer to input polynomial                                                
**************************************************/
fn _poly_decompose (reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  reg u32 i;
  reg u32 q;

  q = __Q();

  i = 0;
  while (i < N) {
    reg u32 a0_, a1_, a_;
    a_ = a[(int) i];
    a0_, a1_ = __decompose_a0a1(a_, q);
    a0[(int) i] = a0_;
    a1[(int) i] = a1_;
    i += 1;
  }

  return a1, a0;
}

// equivalent to _poly_decompose(a1, a0, a1)
fn _poly_decompose_inplace (reg ptr u32[N] a1, reg ptr u32[N] a0) -> reg ptr u32[N], reg ptr u32[N] {
  reg u32 i;
  reg u32 q;

  q = __Q();

  i = 0;
  while (i < N) {
    reg u32 a0_, a1_, a_;
    a_ = a1[(int) i];
    a0_, a1_ = __decompose_a0a1(a_, q);
    a0[(int) i] = a0_;
    a1[(int) i] = a1_;
    i += 1;
  }

  return a1, a0;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyeta_pack
*
* Description: Bit-pack polynomial with coefficients in [-ETA,ETA].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYETA_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/

inline fn __eta_minus_coeff(reg ptr u32[N] a, reg u32 i) -> reg u32 {
  reg u32 c;
  c = a[(int) i];
  c = ETA - c;
  return c;  
}

inline fn __polyeta_pack(reg ptr u8[POLYETA_PACKEDBYTES] r, reg ptr u32[N] a) ->
       reg ptr u8[POLYETA_PACKEDBYTES] {

  reg u32 i, j;
  reg u32[8] t;
  
  /*
  for (i = 0; i < N / 8; ++i) {
      t[0] = (uint8_t) (ETA - a->coeffs[8 * i + 0]);
      t[1] = (uint8_t) (ETA - a->coeffs[8 * i + 1]);
      t[2] = (uint8_t) (ETA - a->coeffs[8 * i + 2]);
      t[3] = (uint8_t) (ETA - a->coeffs[8 * i + 3]);
      t[4] = (uint8_t) (ETA - a->coeffs[8 * i + 4]);
      t[5] = (uint8_t) (ETA - a->coeffs[8 * i + 5]);
      t[6] = (uint8_t) (ETA - a->coeffs[8 * i + 6]);
      t[7] = (uint8_t) (ETA - a->coeffs[8 * i + 7]);
  
      r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
      r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
      r[3 * i + 2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
  }
  */
  
  i = 0; j = 0;
  while(i < N) {
    inline int k;
    for k = 0 to 8 {
      t[k] = __eta_minus_coeff(a, i);
      i += 1;
    }
    reg u32 aux;
    aux = t[0] | t[1] << 3;  aux |= t[2] << 6;
    r[(int) j] = aux; j += 1;
    aux = #UBFX(t[2], 2, 6); aux |= t[3] << 1; aux |= t[4] << 4; aux |= t[5] << 7;
    r[(int) j] = aux; j += 1;
    aux = #UBFX(t[5], 1, 7); aux |= t[6] << 2; aux |= t[7] << 5;
    r[(int) j] = aux; j += 1;
  }
  return r;
  
}

fn _polyeta_pack(reg ptr u8[POLYETA_PACKEDBYTES] r, reg ptr u32[N] a) ->
       reg ptr u8[POLYETA_PACKEDBYTES] {
   r = __polyeta_pack(r, a);
   return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyeta_unpack
*
* Description: Unpack polynomial with coefficients in [-ETA,ETA].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/

inline fn __polyeta_unpack(reg ptr u32[N] r, reg ptr u8[POLYETA_PACKEDBYTES] a) -> reg ptr u32[N] {

  reg u32 i, j;
  reg u32[3] t;
  inline int k;
  reg u32 aux;
  i = 0; j = 0;
  while(i < N) {
  
    for k = 0 to 3 { t[k] = (32u) a[(int) j]; j +=1; }
    
    /* r->coeffs[8 * i + 0] =  (a[3 * i + 0] >> 0) & 7;
       r->coeffs[8 * i + 0] = ETA - r->coeffs[8 * i + 0]; */
    aux = #UBFX(t[0], 0, 3); aux = ETA - aux;
    r[(int) i] = aux; i += 1; 
  
    /* r->coeffs[8 * i + 1] =  (a[3 * i + 0] >> 3) & 7;
       r->coeffs[8 * i + 1] = ETA - r->coeffs[8 * i + 1]; */
    aux = #UBFX(t[0], 3, 3); aux = ETA - aux; 
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 2] = ((a[3 * i + 0] >> 6) | (a[3 * i + 1] << 2)) & 7;
       r->coeffs[8 * i + 2] = ETA - r->coeffs[8 * i + 2]; */
    aux = t[0] >> 6; aux |= t[1] << 2; aux &= 7; aux = ETA - aux;
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 3] =  (a[3 * i + 1] >> 1) & 7;
       r->coeffs[8 * i + 3] = ETA - r->coeffs[8 * i + 3]; */
    aux = #UBFX(t[1], 1, 3); aux = ETA - aux;
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 4] =  (a[3 * i + 1] >> 4) & 7;
       r->coeffs[8 * i + 4] = ETA - r->coeffs[8 * i + 4]; */
    aux = #UBFX(t[1], 4, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 5] = ((a[3 * i + 1] >> 7) | (a[3 * i + 2] << 1)) & 7;
       r->coeffs[8 * i + 5] = ETA - r->coeffs[8 * i + 5]; */
    aux = t[1] >> 7; aux |= t[2] << 1; aux &= 7; aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 6] =  (a[3 * i + 2] >> 2) & 7;
       r->coeffs[8 * i + 6] = ETA - r->coeffs[8 * i + 6]; */
    aux = #UBFX(t[2], 2, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 7] =  (a[3 * i + 2] >> 5) & 7;
       r->coeffs[8 * i + 7] = ETA - r->coeffs[8 * i + 7]; */
    aux = #UBFX(t[2],5, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
  }
  return r;  
}

fn _polyeta_unpack(reg ptr u32[N] r, reg ptr u8[POLYETA_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyeta_unpack(r, a);
  return r;
} 


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_ntt
*
* Description: Inplace forward NTT. Coefficients can grow by
*              8*Q in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_ntt(reg ptr u32[N] a) -> reg ptr u32[N] {
  // We use _ntt and not __ntt because these functions read global data
  // and they need to be close to that data
  a = _ntt(a);
  return a;
}

fn _poly_ntt(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __poly_ntt(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_invntt_tomont
*
* Description: Inplace inverse NTT and multiplication by 2^{32}.
*              Input coefficients need to be less than Q in absolute
*              value and output coefficients are again bounded by Q.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_invntt_tomont(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __invntt_tomont(a);    
  return a;
}

inline fn _poly_invntt_tomont(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = _invntt_tomont(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_pointwise_montgomery
*
* Description: Pointwise multiplication of polynomials in NTT domain
*              representation and multiplication of resulting polynomial
*              by 2^{-32}.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial
**************************************************/
inline fn __poly_pointwise_montgomery(reg ptr u32[N] c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  reg u32 i, a_, b_, c_;
  i = 0;
  while (i < N) {
    a_ = a[(int) i]; b_ = b[(int) i];
    c_ = __mul_montgomery_reduce_8380417(a_, b_);
    c[(int) i] = c_;
    i += 1;
  }
  return c;
}

fn _poly_pointwise_montgomery(reg ptr u32[N] c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  c = __poly_pointwise_montgomery(c, a, b);
  return c;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_make_hint
*
* Description: Compute hint polynomial. The coefficients of which indicate
*              whether the low bits of the corresponding coefficient of
*              the input polynomial overflow into the high bits.
*
* Arguments:   - poly *h: pointer to output hint polynomial
*              - const poly *a0: pointer to low part of input polynomial
*              - const poly *a1: pointer to high part of input polynomial
*
* Returns number of 1 bits.
**************************************************/
/* FIXME: is it constant time? Check __make_hint */
inline fn __poly_make_hint(reg ptr u32[N] h, reg ptr u32[N] a0, reg ptr u32[N] a1) -> reg u32, reg ptr u32[N]{
  reg u32 i, s, a0_, a1_, h_, gamma2;
  gamma2 = __GAMMA2();
  i = 0; s = 0;
  while (i < N) {
    a0_ = a0[(int) i];
    a1_ = a1[(int) i];
    h_ = __make_hint(a0_, a1_, gamma2);
    h[(int) i] = h_; 
    s += h_;
    i += 1;	 
  }
  return s, h;
}

fn _poly_make_hint(reg ptr u32[N] h, reg ptr u32[N] a0, reg ptr u32[N] a1) -> reg u32, reg ptr u32[N] {
  reg u32 s;
  s, h = __poly_make_hint(h, a0, a1);
  return s, h;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_power2round
*
* Description: For all coefficients c of the input polynomial,
*              compute c0, c1 such that c mod Q = c1*2^D + c0
*              with -2^{D-1} < c0 <= 2^{D-1}. Assumes coefficients to be
*              standard representatives.
*
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
*              - poly *a0: pointer to output polynomial with coefficients c0
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __poly_power2round(reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  reg u32 i, a_, a0_, a1_;
    
  i = 0;
  while (i < N) {
    a_ = a[(int) i];
    a0_, a1_ = __power2round_a0a1(a_);
    a0[(int) i] = a0_; a1[(int) i] = a1_;
    i += 1;	
  }
  return (a1, a0);
}

fn _poly_power2round(reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  a1, a0 = __poly_power2round(a1, a0, a);
  return (a1, a0);
}

fn _poly_power2round_inplace(reg ptr u32[N] a1, reg ptr u32[N] a0) -> reg ptr u32[N], reg ptr u32[N] {
  reg u32 i, a_, a0_, a1_;

  i = 0;
  while (i < N) {
    a_ = a1[(int) i];
    a0_, a1_ = __power2round_a0a1(a_);
    a0[(int) i] = a0_; a1[(int) i] = a1_;
    i += 1;
  }
  return (a1, a0);
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_shiftl
*
* Description: Multiply polynomial by 2^D without modular reduction. Assumes
*              input coefficients to be less than 2^{31-D} in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_shiftl(reg ptr u32[N] a) -> reg ptr u32[N] {
  reg u32 i, a_;
  
  i = 0;
  while (i < N) {
    a_ = a[(int) i];
    a_ <<= D;
    a[(int) i] = a_;
    i += 1;    
  }
  return a;
}

fn _poly_shiftl(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __poly_shiftl(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_sub
*
* Description: Subtract polynomials. No modular reduction is
*              performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial to be
*                               subtraced from first input polynomial
**************************************************/

inline fn __poly_sub(reg ptr u32[N]c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  reg u32 i, a_, b_, c_; 

  i = 0;
  while(i < N) {
    a_ = a[(int) i];
    b_ = b[(int) i];
    c_ = a_ - b_;
    c[(int) i] = c_;
    i += 1;
  }
  return c;
}

fn _poly_sub(reg ptr u32[N]c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  c = __poly_sub(c, a, b);
  return c;
}

inline fn __poly_sub_inplace(reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  reg u32 i, a_, b_, c_; 

  i = 0;
  while(i < N) {
    a_ = a[(int) i];
    b_ = b[(int) i];
    c_ = a_ - b_;
    a[(int) i] = c_;
    i += 1;
  }
  return a;
}

fn _poly_sub_inplace(reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  a = __poly_sub_inplace(a, b);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyt0_pack
*
* Description: Bit-pack polynomial t0 with coefficients in ]-2^{D-1}, 2^{D-1}].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYT0_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __polyt0_pack(reg ptr u8[POLYT0_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT0_PACKEDBYTES] {
  reg u32 i, j, aux;
  reg u32[8] t;
  inline int k;
    
  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 8 {
      t[k] = a[(int) i]; i += 1;
      t[k] = (1 << (D - 1)) - t[k];
    }	
    /* r[13 * i + 0]  =  (uint8_t) t[0];           */
    r[(int) j] = t[0]; j += 1;   // j = 1
    
    /* r[13 * i + 1]  =  (uint8_t) (t[0] >>  8);   */
    /* r[13 * i + 1] |=  (uint8_t) (t[1] <<  5);   */
    aux = t[0] >> 8; aux |= t[1] << 5;
    r[(int) j] = aux; j += 1;  // j = 2
    
    /* r[13 * i + 2]  =  (uint8_t) (t[1] >>  3);   */
    aux = t[1] >> 3;
    r[(int) j] = aux; j += 1;   // j = 3
    
    /* r[13 * i + 3]  =  (uint8_t) (t[1] >> 11);   */
    /* r[13 * i + 3] |=  (uint8_t) (t[2] <<  2);   */
    aux = t[1] >> 11; aux |= t[2] << 2;
    r[(int) j] = aux; j += 1;  // j = 4

    /* r[13 * i + 4]  =  (uint8_t) (t[2] >>  6);   */
    /* r[13 * i + 4] |=  (uint8_t) (t[3] <<  7);   */
    aux = t[2] >> 6; aux |= t[3] << 7;
    r[(int) j] = aux; j += 1; // j = 5
    
    /* r[13 * i + 5]  =  (uint8_t) (t[3] >>  1);   */
    aux = t[3] >> 1;
    r[(int) j] = aux; j += 1; // j = 6
    
    /* r[13 * i + 6]  =  (uint8_t) (t[3] >>  9);   */
    /* r[13 * i + 6] |=  (uint8_t) (t[4] <<  4);   */
    aux = t[3] >> 9; aux |= t[4] << 4;
    r[(int) j] = aux; j += 1; // j = 7
    
    /* r[13 * i + 7]  =  (uint8_t) (t[4] >>  4);   */
    aux = t[4] >> 4;
    r[(int) j] = aux; j += 1;  // j = 8
    
    /* r[13 * i + 8]  =  (uint8_t) (t[4] >> 12);   */
    /* r[13 * i + 8] |=  (uint8_t) (t[5] <<  1);   */
    aux = t[4] >> 12; aux |= t[5] << 1;
    r[(int) j] = aux; j += 1;  // j = 9
    
    /* r[13 * i + 9]  =  (uint8_t) (t[5] >>  7);   */
    /* r[13 * i + 9] |=  (uint8_t) (t[6] <<  6);   */
    aux = t[5] >> 7; aux |= t[6] << 6;
    r[(int) j] = aux; j += 1;  // j = 10
    
    /* r[13 * i + 10]  =  (uint8_t) (t[6] >>  2);  */
    aux = t[6] >> 2;
    r[(int) j] = aux; j += 1;  // j = 11
    
    /* r[13 * i + 11]  =  (uint8_t) (t[6] >> 10);  */
    /* r[13 * i + 11] |=  (uint8_t) (t[7] <<  3);  */
    aux = t[6] >> 10; aux |= t[7] << 3;
    r[(int) j] = aux; j += 1; // j = 12
    
    /* r[13 * i + 12]  =  (uint8_t) (t[7] >>  5);  */
    aux = t[7] >> 5;
    r[(int)j] = aux; j += 1;  // j = 13
  }
  return r;
}

fn _polyt0_pack(reg ptr u8[POLYT0_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT0_PACKEDBYTES] {
  r = __polyt0_pack(r, a);
  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyt0_unpack
*
* Description: Unpack polynomial t0 with coefficients in ]-2^{D-1}, 2^{D-1}].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/
inline fn __polyt0_unpack(reg ptr u32[N] r, reg ptr u8[POLYT0_PACKEDBYTES] a) -> reg ptr u32[N] {
  reg u32 i, j, a_;
  reg u32[8] t;
  
  i = 0; j = 0;
  while(i < N) {
    /*  r->coeffs[8 * i + 0]  = a[13 * i + 0];
        r->coeffs[8 * i + 0] |= (uint32_t)a[13 * i + 1] << 8;
        r->coeffs[8 * i + 0] &= 0x1FFF; */
    t[0] = (32u) a[(int) j]; j += 1;  // j = 1
    a_ = (32u) a[(int) j]; j += 1;    // j = 2  a_ = a[1]
    t[0] |= a_ << 8;
    t[0] = #UBFX(t[0], 0, 13);
	
    t[0] = (1 << (D - 1)) - t[0];
    r[(int) i] = t[0]; i += 1;
	
    /*  r->coeffs[8 * i + 1]  = a[13 * i + 1] >> 5;
        r->coeffs[8 * i + 1] |= (uint32_t)a[13 * i + 2] << 3;
        r->coeffs[8 * i + 1] |= (uint32_t)a[13 * i + 3] << 11;
        r->coeffs[8 * i + 1] &= 0x1FFF; */
    t[1] = a_ >> 5;
    a_ = (32u) a[(int) j]; j += 1; // j = 3
    t[1] |= a_ << 3;
    a_ = (32u) a[(int) j]; j += 1; // j = 4 a_ = a[3]
    t[1] |= a_ << 11;
    t[1] = #UBFX(t[1], 0, 13);

    t[1] = (1 << (D - 1)) - t[1];
    r[(int) i] = t[1]; i += 1;
	
    /*  r->coeffs[8 * i + 2]  = a[13 * i + 3] >> 2;
        r->coeffs[8 * i + 2] |= (uint32_t)a[13 * i + 4] << 6;
        r->coeffs[8 * i + 2] &= 0x1FFF; */
    t[2] = a_ >> 2;
    a_ = (32u) a[(int) j]; j += 1;  // j = 5  a_ = a[4]
    t[2] |= a_ << 6;
    t[2] = #UBFX(t[2], 0, 13);
    
    t[2] = (1 << (D - 1)) - t[2];
    r[(int) i] = t[2]; i += 1;
	    
    /*  r->coeffs[8 * i + 3]  = a[13 * i + 4] >> 7;
        r->coeffs[8 * i + 3] |= (uint32_t)a[13 * i + 5] << 1;
        r->coeffs[8 * i + 3] |= (uint32_t)a[13 * i + 6] << 9;
        r->coeffs[8 * i + 3] &= 0x1FFF; */
    t[3] = a_ >> 7;
    a_ = (32u) a[(int) j]; j += 1;  // j = 6
    t[3] |= a_ << 1;
    a_ = (32u) a[(int) j]; j += 1; // j = 7 a_ = a[6]
    t[3] |= a_ << 9;
    t[3] = #UBFX(t[3], 0, 13);
    
    t[3] = (1 << (D - 1)) - t[3];
    r[(int) i] = t[3]; i += 1;
	
    /*  r->coeffs[8 * i + 4]  = a[13 * i + 6] >> 4;
        r->coeffs[8 * i + 4] |= (uint32_t)a[13 * i + 7] << 4;
        r->coeffs[8 * i + 4] |= (uint32_t)a[13 * i + 8] << 12;
        r->coeffs[8 * i + 4] &= 0x1FFF; */
    t[4] = a_ >> 4;
    a_ = (32u) a[(int) j]; j += 1;  // j = 8
    t[4] |=	a_ << 4;
    a_ = (32u) a[(int) j]; j += 1; // j = 9   a_ = a[8]
    t[4] |= a_ << 12;
    t[4] = #UBFX(t[4], 0, 13);
    
    t[4] = (1 << (D - 1)) - t[4];
    r[(int) i] = t[4]; i += 1;

	
    /*  r->coeffs[8 * i + 5]  = a[13 * i + 8] >> 1;
        r->coeffs[8 * i + 5] |= (uint32_t)a[13 * i + 9] << 7;
        r->coeffs[8 * i + 5] &= 0x1FFF; */
    t[5] = a_ >> 1;
    a_ = (32u) a[(int) j]; j += 1; // j = 10   a_ = a[9]
    t[5] |= a_ << 7;
    t[5] = #UBFX(t[5], 0, 13);

    t[5] = (1 << (D - 1)) - t[5];
    r[(int) i] = t[5]; i += 1;

    /*  r->coeffs[8 * i + 6]  = a[13 * i + 9] >> 6;
        r->coeffs[8 * i + 6] |= (uint32_t)a[13 * i + 10] << 2;
        r->coeffs[8 * i + 6] |= (uint32_t)a[13 * i + 11] << 10;
        r->coeffs[8 * i + 6] &= 0x1FFF; */
    t[6] = a_ >> 6;
    a_ = (32u) a[(int) j]; j += 1; // j = 11   a_ = a[10]
    t[6] |= a_ << 2;
    a_ = (32u) a[(int) j]; j += 1; // j = 12   a_ = a[11]
    t[6] |= a_ << 10;
    t[6] = #UBFX(t[6], 0, 13);
    
    t[6] = (1 << (D - 1)) - t[6];
    r[(int) i] = t[6]; i += 1;
	
    /*  r->coeffs[8 * i + 7]  = a[13 * i + 11] >> 3;
        r->coeffs[8 * i + 7] |= (uint32_t)a[13 * i + 12] << 5;
        r->coeffs[8 * i + 7] &= 0x1FFF; */
    t[7] = a_ >> 3;
    a_ = (32u) a[(int) j]; j += 1; // j = 13   a_ = a[12]
    t[7] |= a_ << 5;
    t[7] = #UBFX(t[7], 0, 13);

    t[7] = (1 << (D - 1)) - t[7];
    r[(int) i] = t[7]; i += 1;

    /* This is moved up */
    /*  r->coeffs[8 * i + 0] = (1 << (D - 1)) - r->coeffs[8 * i + 0];
        r->coeffs[8 * i + 1] = (1 << (D - 1)) - r->coeffs[8 * i + 1];
        r->coeffs[8 * i + 2] = (1 << (D - 1)) - r->coeffs[8 * i + 2];
        r->coeffs[8 * i + 3] = (1 << (D - 1)) - r->coeffs[8 * i + 3];
        r->coeffs[8 * i + 4] = (1 << (D - 1)) - r->coeffs[8 * i + 4];
        r->coeffs[8 * i + 5] = (1 << (D - 1)) - r->coeffs[8 * i + 5];
        r->coeffs[8 * i + 6] = (1 << (D - 1)) - r->coeffs[8 * i + 6];
        r->coeffs[8 * i + 7] = (1 << (D - 1)) - r->coeffs[8 * i + 7]; */


  }
  return r;
}

fn _polyt0_unpack(reg ptr u32[N] r, reg ptr u8[POLYT0_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyt0_unpack(r, a);
  return r;
}  

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyt1_pack
*
* Description: Bit-pack polynomial t1 with coefficients fitting in 10 bits.
*              Input coefficients are assumed to be standard representatives.
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYT1_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __polyt1_pack(reg ptr u8[POLYT1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT1_PACKEDBYTES] {
  reg u32 i, j, aux;
  reg u32[4] t;
  inline int k;
  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 4 {
      t[k] = a[(int) i]; i += 1;
    }
    /* r[5 * i + 0] = (uint8_t) (a->coeffs[4 * i + 0] >> 0); */
    r[(int) j] = t[0]; j += 1;
    
    /* r[5 * i + 1] = (uint8_t) ((a->coeffs[4 * i + 0] >> 8) | (a->coeffs[4 * i + 1] << 2)); */
    aux = t[0] >> 8; aux |= t[1] << 2;
    r[(int) j] = aux; j += 1;

    /* r[5 * i + 2] = (uint8_t) ((a->coeffs[4 * i + 1] >> 6) | (a->coeffs[4 * i + 2] << 4)); */
    aux = t[1] >> 6; aux |= t[2] << 4;
    r[(int) j] = aux; j += 1;

    /* r[5 * i + 3] = (uint8_t) ((a->coeffs[4 * i + 2] >> 4) | (a->coeffs[4 * i + 3] << 6)); */
    aux = t[2] >> 4; aux |= t[3] << 6;
    r[(int) j] = aux; j += 1;
    
    /* r[5 * i + 4] = (uint8_t) (a->coeffs[4 * i + 3] >> 2);                                 */
    aux = t[3] >> 2;
    r[(int) j] = aux; j += 1;
  }
  return r;
}

fn _polyt1_pack(reg ptr u8[POLYT1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT1_PACKEDBYTES] {
  r = __polyt1_pack(r, a);
  return r;
}	 

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyt1_unpack
*
* Description: Unpack polynomial t1 with 10-bit coefficients.
*              Output coefficients are standard representatives.
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/
inline fn __polyt1_unpack(reg ptr u32[N] r, reg ptr u8[POLYT1_PACKEDBYTES] a) -> reg ptr u32[N] {
  reg u32 i, j, aux;
  reg u32[5] t;
  inline int k;
  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 5 {
      t[k] = (32u) a[(int) j]; j += 1;
    }	
  
    /* r->coeffs[4 * i + 0] = ((a[5 * i + 0] >> 0) | ((uint32_t)a[5 * i + 1] << 8)) & 0x3FF; */
    aux = t[0] | (t[1] << 8); aux = #UBFX(aux, 0, 10);
    r[(int) i] = aux; i += 1;
  
    /* r->coeffs[4 * i + 1] = ((a[5 * i + 1] >> 2) | ((uint32_t)a[5 * i + 2] << 6)) & 0x3FF; */
    aux = t[1] >> 2; aux |= t[2] << 6; aux = #UBFX(aux, 0, 10);
    r[(int) i] = aux;	i += 1;
  
    /* r->coeffs[4 * i + 2] = ((a[5 * i + 2] >> 4) | ((uint32_t)a[5 * i + 3] << 4)) & 0x3FF; */
    aux = t[2] >> 4; aux |= t[3] << 4; aux = #UBFX(aux, 0, 10);
    r[(int) i] = aux; i += 1;
  
    /* r->coeffs[4 * i + 3] = ((a[5 * i + 3] >> 6) | ((uint32_t)a[5 * i + 4] << 2)) & 0x3FF; */
    aux = t[3] >> 6; aux |= t[4] << 2; aux = #UBFX(aux, 0, 10);
    r[(int) i] = aux; i += 1;
    
  }
  return r;
}

fn _polyt1_unpack(reg ptr u32[N] r, reg ptr u8[POLYT1_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyt1_unpack(r, a);
  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_use_hint
*
* Description: Use hint polynomial to correct the high bits of a polynomial.
*
* Arguments:   - poly *b: pointer to output polynomial with corrected high bits
*              - const poly *a: pointer to input polynomial
*              - const poly *h: pointer to input hint polynomial
**************************************************/
inline fn __poly_use_hint(reg ptr u32[N] b, reg ptr u32[N] a, reg ptr u32[N] h) -> reg ptr u32[N] {
  reg u32 i, b_, a_, h_, q;       

  q = __Q();
  i = 0;
  while(i < N) {
    a_ = a[(int) i];
    h_ = h[(int) i];
    b_ = __use_hint(a_, h_, q);
    b[(int) i] = b_;
    i += 1;
  }
  return b;
}

fn _poly_use_hint(reg ptr u32[N] b, reg ptr u32[N] a, reg ptr u32[N] h) -> reg ptr u32[N] {
  b = __poly_use_hint(b, a, h);
  return b;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyw1_pack
*
* Description: Bit-pack polynomial w1 with coefficients in [0,15] or [0,43].
*              Input coefficients are assumed to be standard representatives.
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYW1_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/

inline fn __polyw1_pack(reg ptr u8[POLYW1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYW1_PACKEDBYTES] {
  reg u32 i, j, aux;
  reg u32[2] t;
  inline int k;
  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 2 { t[k] = a[(int) i]; i += 1; }
    aux = t[0] | t[1] << 4;
    r[(int) j] = aux; j += 1;
  }
  return r;
}

fn _polyw1_pack(reg ptr u8[POLYW1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYW1_PACKEDBYTES] {
  r = __polyw1_pack(r, a);
  return r;
}


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyz_pack
*
* Description: Bit-pack polynomial with coefficients
*              in [-(GAMMA1 - 1), GAMMA1].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYZ_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __polyz_pack(reg ptr u8[POLYZ_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYZ_PACKEDBYTES] {
  reg u32 i, j, aux, gamma1;
  reg u32[2] t;
  inline int k;

  gamma1 = __GAMMA1();

  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 2 {
       t[k] = a[(int) i]; t[k] = gamma1 - t[k];
       i += 1;
    }

    /* r[5 * i + 0]  = (uint8_t) t[0]; */
    r[(int) j] = t[0]; j += 1;
    
    /* r[5 * i + 1]  = (uint8_t) (t[0] >> 8); */
    aux = t[0] >> 8;
    r[(int) j] = aux; j += 1;
    
    /* r[5 * i + 2]  = (uint8_t) (t[0] >> 16); */
    /* r[5 * i + 2] |= (uint8_t) (t[1] << 4); */
    aux = t[0] >> 16; aux |= t[1] << 4;
    r[(int) j] = aux; j += 1;

    /* r[5 * i + 3]  = (uint8_t) (t[1] >> 4); */
    aux = t[1] >> 4;
    r[(int) j] = aux; j += 1;

    /* r[5 * i + 4]  = (uint8_t) (t[1] >> 12); */
    aux = t[1] >> 12;
    r[(int) j] = aux; j += 1;

  }
  return r;
}

fn _polyz_pack(reg ptr u8[POLYZ_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYZ_PACKEDBYTES] {
  r = __polyz_pack(r, a);
  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyz_unpack
*
* Description: Unpack polynomial z with coefficients
*              in [-(GAMMA1 - 1), GAMMA1].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/

inline fn __polyz_unpack(reg ptr u32[N] r, reg ptr u8[POLYZ_PACKEDBYTES] a) -> reg ptr u32[N] {
  reg u32 i, j, gamma1, aux;
  reg u32[5] t;
  inline int k;
  
  gamma1 = __GAMMA1();
  i = 0; j = 0;
  while(i < N) {
    for k = 0 to 5 { t[k] = (32u) a[(int) j]; j += 1; }
    
    /* r->coeffs[2 * i + 0]  = a[5 * i + 0];  
       r->coeffs[2 * i + 0] |= (uint32_t)a[5 * i + 1] << 8; 
       r->coeffs[2 * i + 0] |= (uint32_t)a[5 * i + 2] << 16; 
       r->coeffs[2 * i + 0] &= 0xFFFFF; */
    aux = t[0] | (t[1] << 8);
    aux |= t[2] << 16;
    aux = #UBFX(aux, 0, 20);
    aux = gamma1 - aux;
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[2 * i + 1]  = a[5 * i + 2] >> 4; */
    /* r->coeffs[2 * i + 1] |= (uint32_t)a[5 * i + 3] << 4; */
    /* r->coeffs[2 * i + 1] |= (uint32_t)a[5 * i + 4] << 12; */
    /* r->coeffs[2 * i + 0] &= 0xFFFFF; */  // this look like a lucky bug
    aux = t[2] >> 4;
    aux |= t[3] << 4;
    aux |= t[4] << 12;
    aux = gamma1 - aux;
    r[(int) i] = aux; i += 1;

    // Moved up
    /* r->coeffs[2 * i + 0] = GAMMA1 - r->coeffs[2 * i + 0]; */
    /* r->coeffs[2 * i + 1] = GAMMA1 - r->coeffs[2 * i + 1]; */
  }
  return r;
}

fn _polyz_unpack(reg ptr u32[N] r, reg ptr u8[POLYZ_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyz_unpack(r, a);
  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_uniform
*
* Description: Sample polynomial with uniformly random coefficients
*              in [0,Q-1] by performing rejection sampling on the
*              output stream of SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
*
* Arguments:   - poly *a: pointer to output polynomial
*              - const uint8_t seed[]: byte array with seed of length SEEDBYTES
*              - uint16_t nonce: 2-byte nonce
**************************************************/
inline fn __rej_sample(
  reg ptr u32[N] a, 
  reg u32 ctr, 
  reg u32 t, 
  reg u32 q
) -> reg ptr u32[N], reg u32 
{
  inline bool b;
  ?{"<u" = b} = #CMP(t, q);
  a[(int) ctr] = t if (b);
  ctr = ctr + 1 if (b);
  return a, ctr;
}

inline fn __extr_rej_sample(
  reg ptr u32[N] a, 
  reg u32 ctr, 
  reg u32 t, 
  reg u32 q
) -> reg ptr u32[N], reg u32 
{
  t = #UBFX(t,0, 23);
  a, ctr = __rej_sample(a, ctr, t, q);
  return a, ctr;
}

fn _poly_uniform(reg ptr u32[N] a,
                 reg ptr u8[SEEDBYTES] seed,
                 reg u32 nonce
) -> reg ptr u32[N]
{
  stack u32[25*2] state_;
  reg ptr u32[25*2] state;
  stack ptr u32[N] sa;
  sa = a; state = state_;
  state = _stream128_init(state, seed, nonce);
  a = sa;
  
  reg u32 ctr, ctr4, pos, q, t;
  reg u32[3] buf;

  ctr = 0; pos = 0; q = __Q();

  
  while { ctr4 = ctr + 4; } (ctr4 < N) {

    state, a, pos, ctr, q, buf = _stream128_refill_buffer(state, a, pos, ctr, q);

    a, ctr = __extr_rej_sample(a, ctr, buf[0], q);  // 3 bytes in buf[0]

    t = buf[0] >>u 24; t |= buf[1] << 8;    // 1 byte in buf[0] U 2 bytes in buf[1]
    a, ctr = __extr_rej_sample(a, ctr, t, q);

    t = buf[1] >>u 16; t |= buf[2] << 16;  // 2 byte in buf[1] U 1 bytes in buf[2]
    a, ctr = __extr_rej_sample(a, ctr, t, q);

    t = #UBFX(buf[2], 8, 23);
    a, ctr = __rej_sample(a, ctr, t, q);

  }

  while (ctr < N) {
    state, a, pos, ctr, q, buf = _stream128_refill_buffer(state, a, pos, ctr, q);

    a, ctr = __extr_rej_sample(a, ctr, buf[0], q);  // 3 bytes in buf[0]

    if (ctr < N) {
      t = buf[0] >>u 24; t |= buf[1] << 8;    // 1 byte in buf[0] U 2 bytes in buf[1]
      a, ctr = __extr_rej_sample(a, ctr, t, q);
    }

    if (ctr < N) {
      t = buf[1] >>u 16; t |= buf[2] << 16;  // 2 byte in buf[1] U 1 bytes in buf[2]
      a, ctr = __extr_rej_sample(a, ctr, t, q);
    }

    if (ctr < N) {
      t = #UBFX(buf[2], 8, 23);
      a, ctr = __rej_sample(a, ctr, t, q);
    }
  }
  return a;
} 

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_uniform_eta
*
* Description: Sample polynomial with uniformly random coefficients
*              in [-ETA,ETA] by performing rejection sampling on the
*              output stream from SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
*
* Arguments:   - poly *a: pointer to output polynomial
*              - const uint8_t seed[]: byte array with seed of length CRHBYTES
*              - uint16_t nonce: 2-byte nonce
**************************************************/

inline fn rej_eta(
  reg ptr u32[N] a, 
  reg u32 ctr, 
  reg u32 t,
  reg u32 n205
) -> reg ptr u32[N], reg u32 
{
  if (t < 15) {
    reg u32 aux;
    aux = t * n205;
    aux = aux >> 10;
    aux = aux + (aux << 2);  /* aux *= 5 */
    aux = t - aux;
    aux = 2 - aux;
    a[(int) ctr] = aux;
    ctr += 1;
  }
  return a, ctr;
}

fn _poly_uniform_eta(reg ptr u32[N] a,
                 reg ptr u8[CRHBYTES] seed,
                 reg u32 nonce
) -> reg ptr u32[N]
{
  stack u32[25*2] state_;
  reg ptr u32[25*2] state;
  stack ptr u32[N] sa;
  sa = a; state = state_;
  state = _stream256_init(state, seed, nonce);
  a = sa;
  
  reg u32 ctr, ctr8, pos, n205, t;
  reg u32 buf;

  ctr = 0; pos = 0; n205 = 205;

  while { ctr8 = ctr + 8; } (ctr8 < N) {

    state, a, pos, ctr, n205, buf = _stream256_refill_buffer(state, a, pos, ctr, n205);
    inline int i;
    for i = 0 to 8 {
      t = #UBFX(buf, 4*i, 4);
      a, ctr = rej_eta(a, ctr, t, n205);
    }     
  }

  while (ctr < N) {
    state, a, pos, ctr, n205, buf = _stream256_refill_buffer(state, a, pos, ctr, n205);
    inline int i;
    for i = 0 to 8 {
      if ((i == 0) || (ctr < N)) { 
        t = #UBFX(buf, 4*i, 4);
        a, ctr = rej_eta(a, ctr, t, n205);
      }
    }       
  } 
  return a;
} 

param int polyz_last = POLYZ_PACKEDBYTES / SHAKE256_RATE * SHAKE256_RATE;
param int polyz_last_sz = POLYZ_PACKEDBYTES % SHAKE256_RATE;


fn _poly_uniform_gamma1(reg ptr u32[N] a,
                 reg ptr u8[CRHBYTES] seed,
                 reg u32 nonce
) -> reg ptr u32[N]
{
  stack u8[POLYZ_PACKEDBYTES] buf_;
  reg ptr u8[POLYZ_PACKEDBYTES] buf;
  reg ptr u8[SHAKE256_RATE] bufb;
  stack u32[25*2] state_;
  reg ptr u32[25*2] state;
  stack ptr u32[N] sa;
  sa = a; state = state_;
  state = _stream256_init(state, seed, nonce);
  
  inline int k;
  for k = 0 to POLYZ_PACKEDBYTES / SHAKE256_RATE {
    bufb = buf_[SHAKE256_RATE * k : SHAKE256_RATE];
    bufb = _stream256_full_squeeze(bufb, state);
    buf_[SHAKE256_RATE * k : SHAKE256_RATE] = bufb;
    state = _keccakf1600_ref(state);
  }

  reg ptr u8[polyz_last_sz] bufc;
  bufc = buf_[ polyz_last : polyz_last_sz]; 

  reg u32 i, t;
  i = 0;
  while (i < polyz_last_sz / 4) {
    t = state[(int) i];
    bufc[u32 (int) i] = t;
    i += 1;
  }
  buf_[ polyz_last : polyz_last_sz] = bufc;

  buf = buf_; a = sa;
  a = _polyz_unpack(a, buf);
  return a;
}

/*************************************************                                                         
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_decompose                                                     
*                                                                                                          
* Description: For all coefficients c of the input polynomial,                                             
*              compute high and low bits c0, c1 such c mod Q = c1*ALPHA + c0                               
*              with -ALPHA/2 < c0 <= ALPHA/2 except c1 = (Q-1)/ALPHA where we                              
*              set c1 = 0 and -ALPHA/2 <= c0 = c mod Q - Q < 0.                                            
*              Assumes coefficients to be standard representatives.                                        
*                                                                                                          
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1                               
*              - poly *a0: pointer to output polynomial with coefficients c0                               
*              - const poly *a: pointer to input polynomial                                                
**************************************************/
fn _poly_decompose (reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  reg u32 i;
  reg u32 q;

  q = __Q();

  i = 0;
  while (i < N) {
    reg u32 a0_, a1_, a_;
    a_ = a[(int) i];
    a0_, a1_ = __decompose_a0a1(a_, q);
    a0[(int) i] = a0_;
    a1[(int) i] = a1_;
    i += 1;
  }

  return a1, a0;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyeta_pack
*
* Description: Bit-pack polynomial with coefficients in [-ETA,ETA].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYETA_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/

inline fn __eta_minus_coeff(reg ptr u32[N] a, reg u32 i) -> reg u32 {
  reg u32 c;
  c = a[(int) i];
  c = ETA - c;
  return c;  
}

inline fn __polyeta_pack(reg ptr u8[POLYETA_PACKEDBYTES] r, reg ptr u32[N] a) ->
       reg ptr u8[POLYETA_PACKEDBYTES] {

  reg u32 i, j;
  reg u32[8] t;
  
  /*
  for (i = 0; i < N / 8; ++i) {
      t[0] = (uint8_t) (ETA - a->coeffs[8 * i + 0]);
      t[1] = (uint8_t) (ETA - a->coeffs[8 * i + 1]);
      t[2] = (uint8_t) (ETA - a->coeffs[8 * i + 2]);
      t[3] = (uint8_t) (ETA - a->coeffs[8 * i + 3]);
      t[4] = (uint8_t) (ETA - a->coeffs[8 * i + 4]);
      t[5] = (uint8_t) (ETA - a->coeffs[8 * i + 5]);
      t[6] = (uint8_t) (ETA - a->coeffs[8 * i + 6]);
      t[7] = (uint8_t) (ETA - a->coeffs[8 * i + 7]);
  
      r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
      r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
      r[3 * i + 2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
  }
  */
  
  i = 0; j = 0;
  while(i < N) {
    inline int k;
    for k = 0 to 8 {
      t[k] = __eta_minus_coeff(a, i);
      i += 1;
    }
    reg u32 aux;
    aux = t[0] | t[1] << 3;  aux |= t[2] << 6;
    r[(int) j] = aux; j += 1;
    aux = #UBFX(t[2], 2, 6); aux |= t[3] << 1; aux |= t[4] << 4; aux |= t[5] << 7;
    r[(int) j] = aux; j += 1;
    aux = #UBFX(t[5], 1, 7); aux |= t[6] << 2; aux |= t[7] << 5;
    r[(int) j] = aux; j += 1;
  }
  return r;
  
}

fn _polyeta_pack(reg ptr u8[POLYETA_PACKEDBYTES] r, reg ptr u32[N] a) ->
       reg ptr u8[POLYETA_PACKEDBYTES] {
   r = __polyeta_pack(r, a);
   return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyeta_unpack
*
* Description: Unpack polynomial with coefficients in [-ETA,ETA].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/

inline fn __polyeta_unpack(reg ptr u32[N] r, reg ptr u8[POLYETA_PACKEDBYTES] a) -> reg ptr u32[N] {

  reg u32 i, j;
  reg u32[3] t;
  inline int k;
  reg u32 aux;
  i = 0; j = 0;
  while(i < N) {
  
    for k = 0 to 3 { t[k] = (32u) a[(int) j]; j +=1; }
    
    /* r->coeffs[8 * i + 0] =  (a[3 * i + 0] >> 0) & 7;
       r->coeffs[8 * i + 0] = ETA - r->coeffs[8 * i + 0]; */
    aux = #UBFX(t[0], 0, 3); aux = ETA - aux;
    r[(int) i] = aux; i += 1; 
  
    /* r->coeffs[8 * i + 1] =  (a[3 * i + 0] >> 3) & 7;
       r->coeffs[8 * i + 1] = ETA - r->coeffs[8 * i + 1]; */
    aux = #UBFX(t[0], 3, 3); aux = ETA - aux; 
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 2] = ((a[3 * i + 0] >> 6) | (a[3 * i + 1] << 2)) & 7;
       r->coeffs[8 * i + 2] = ETA - r->coeffs[8 * i + 2]; */
    aux = t[0] >> 6; aux |= t[1] << 2; aux &= 7; aux = ETA - aux;
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 3] =  (a[3 * i + 1] >> 1) & 7;
       r->coeffs[8 * i + 3] = ETA - r->coeffs[8 * i + 3]; */
    aux = #UBFX(t[1], 1, 3); aux = ETA - aux;
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 4] =  (a[3 * i + 1] >> 4) & 7;
       r->coeffs[8 * i + 4] = ETA - r->coeffs[8 * i + 4]; */
    aux = #UBFX(t[1], 4, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 5] = ((a[3 * i + 1] >> 7) | (a[3 * i + 2] << 1)) & 7;
       r->coeffs[8 * i + 5] = ETA - r->coeffs[8 * i + 5]; */
    aux = t[1] >> 7; aux |= t[2] << 1; aux &= 7; aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 6] =  (a[3 * i + 2] >> 2) & 7;
       r->coeffs[8 * i + 6] = ETA - r->coeffs[8 * i + 6]; */
    aux = #UBFX(t[2], 2, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 7] =  (a[3 * i + 2] >> 5) & 7;
       r->coeffs[8 * i + 7] = ETA - r->coeffs[8 * i + 7]; */
    aux = #UBFX(t[2],5, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
  }
  return r;  
}

fn _polyeta_unpack(reg ptr u32[N] r, reg ptr u8[POLYETA_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyeta_unpack(r, a);
  return r;
} 


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_ntt
*
* Description: Inplace forward NTT. Coefficients can grow by
*              8*Q in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_ntt(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __ntt(a);
  return a;
}

inline fn _poly_ntt(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = _ntt(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_invntt_tomont
*
* Description: Inplace inverse NTT and multiplication by 2^{32}.
*              Input coefficients need to be less than Q in absolute
*              value and output coefficients are again bounded by Q.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_invntt_tomont(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __invntt_tomont(a);    
  return a;
}

inline fn _poly_invntt_tomont(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = _invntt_tomont(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_pointwise_montgomery
*
* Description: Pointwise multiplication of polynomials in NTT domain
*              representation and multiplication of resulting polynomial
*              by 2^{-32}.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial
**************************************************/
inline fn __poly_pointwise_montgomery(reg ptr u32[N] c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  reg u32 i, a_, b_, c_;
  i = 0;
  while (i < N) {
    a_ = a[(int) i]; b_ = b[(int) i];
    c_ = __mul_montgomery_reduce_8380417(a_, b_);
    c[(int) i] = c_;
    i += 1;
  }
  return c;
}

fn _poly_pointwise_montgomery(reg ptr u32[N] c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  c = __poly_pointwise_montgomery(c, a, b);
  return c;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_make_hint
*
* Description: Compute hint polynomial. The coefficients of which indicate
*              whether the low bits of the corresponding coefficient of
*              the input polynomial overflow into the high bits.
*
* Arguments:   - poly *h: pointer to output hint polynomial
*              - const poly *a0: pointer to low part of input polynomial
*              - const poly *a1: pointer to high part of input polynomial
*
* Returns number of 1 bits.
**************************************************/
/* FIXME: is it constant time? Check __make_hint */
inline fn __poly_make_hint(reg ptr u32[N] h, reg ptr u32[N] a0, reg ptr u32[N] a1) -> reg u32, reg ptr u32[N]{
  reg u32 i, s, a0_, a1_, h_, gamma2;
  gamma2 = __GAMMA2();
  i = 0; s = 0;
  while (i < N) {
    a0_ = a0[(int) i];
    a1_ = a1[(int) i];
    h_ = __make_hint(a0_, a1_, gamma2);
    h[(int) i] = h_; 
    s += h_;
    i += 1;	 
  }
  return s, h;
}

fn _poly_make_hint(reg ptr u32[N] h, reg ptr u32[N] a0, reg ptr u32[N] a1) -> reg u32, reg ptr u32[N] {
  reg u32 s;
  s, h = __poly_make_hint(h, a0, a1);
  return s, h;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_power2round
*
* Description: For all coefficients c of the input polynomial,
*              compute c0, c1 such that c mod Q = c1*2^D + c0
*              with -2^{D-1} < c0 <= 2^{D-1}. Assumes coefficients to be
*              standard representatives.
*
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
*              - poly *a0: pointer to output polynomial with coefficients c0
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __poly_power2round(reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  reg u32 i, a_, a0_, a1_;
    
  i = 0;
  while (i < N) {
    a_ = a[(int) i];
    a0_, a1_ = __power2round_a0a1(a_);
    a0[(int) i] = a0_; a1[(int) i] = a1_;
    i += 1;	
  }
  return (a1, a0);
}

fn _poly_power2round(reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  a1, a0 = __poly_power2round(a1, a0, a);
  return (a1, a0);
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_shiftl
*
* Description: Multiply polynomial by 2^D without modular reduction. Assumes
*              input coefficients to be less than 2^{31-D} in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_shiftl(reg ptr u32[N] a) -> reg ptr u32[N] {
  reg u32 i, a_;
  
  i = 0;
  while (i < N) {
    a_ = a[(int) i];
    a_ <<= D;
    a[(int) i] = a_;
    i += 1;    
  }
  return a;
}

fn _poly_shiftl(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __poly_shiftl(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_sub
*
* Description: Subtract polynomials. No modular reduction is
*              performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial to be
*                               subtraced from first input polynomial
**************************************************/

inline fn __poly_sub(reg ptr u32[N]c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  reg u32 i, a_, b_, c_; 

  i = 0;
  while(i < N) {
    a_ = a[(int) i];
    b_ = b[(int) i];
    c_ = a_ - b_;
    c[(int) i] = c_;
    i += 1;
  }
  return c;
}

fn _poly_sub(reg ptr u32[N]c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  c = __poly_sub(c, a, b);
  return c;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyt0_pack
*
* Description: Bit-pack polynomial t0 with coefficients in ]-2^{D-1}, 2^{D-1}].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYT0_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __polyt0_pack(reg ptr u8[POLYT0_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT0_PACKEDBYTES] {
  reg u32 i, j, aux;
  reg u32[8] t;
  inline int k;
    
  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 8 {
      t[k] = a[(int) i]; i += 1;
      t[k] = (1 << (D - 1)) - t[k];
    }	
    /* r[13 * i + 0]  =  (uint8_t) t[0];           */
    r[(int) j] = t[0]; j += 1;   // j = 1
    
    /* r[13 * i + 1]  =  (uint8_t) (t[0] >>  8);   */
    /* r[13 * i + 1] |=  (uint8_t) (t[1] <<  5);   */
    aux = t[0] >> 8; aux |= t[1] << 5;
    r[(int) j] = aux; j += 1;  // j = 2
    
    /* r[13 * i + 2]  =  (uint8_t) (t[1] >>  3);   */
    aux = t[1] >> 3;
    r[(int) j] = aux; j += 1;   // j = 3
    
    /* r[13 * i + 3]  =  (uint8_t) (t[1] >> 11);   */
    /* r[13 * i + 3] |=  (uint8_t) (t[2] <<  2);   */
    aux = t[1] >> 11; aux |= t[2] << 2;
    r[(int) j] = aux; j += 1;  // j = 4

    /* r[13 * i + 4]  =  (uint8_t) (t[2] >>  6);   */
    /* r[13 * i + 4] |=  (uint8_t) (t[3] <<  7);   */
    aux = t[2] >> 6; aux |= t[3] << 7;
    r[(int) j] = aux; j += 1; // j = 5
    
    /* r[13 * i + 5]  =  (uint8_t) (t[3] >>  1);   */
    aux = t[3] >> 1;
    r[(int) j] = aux; j += 1; // j = 6
    
    /* r[13 * i + 6]  =  (uint8_t) (t[3] >>  9);   */
    /* r[13 * i + 6] |=  (uint8_t) (t[4] <<  4);   */
    aux = t[3] >> 9; aux |= t[4] << 4;
    r[(int) j] = aux; j += 1; // j = 7
    
    /* r[13 * i + 7]  =  (uint8_t) (t[4] >>  4);   */
    aux = t[4] >> 4;
    r[(int) j] = aux; j += 1;  // j = 8
    
    /* r[13 * i + 8]  =  (uint8_t) (t[4] >> 12);   */
    /* r[13 * i + 8] |=  (uint8_t) (t[5] <<  1);   */
    aux = t[4] >> 12; aux |= t[5] << 1;
    r[(int) j] = aux; j += 1;  // j = 9
    
    /* r[13 * i + 9]  =  (uint8_t) (t[5] >>  7);   */
    /* r[13 * i + 9] |=  (uint8_t) (t[6] <<  6);   */
    aux = t[5] >> 7; aux |= t[6] << 6;
    r[(int) j] = aux; j += 1;  // j = 10
    
    /* r[13 * i + 10]  =  (uint8_t) (t[6] >>  2);  */
    aux = t[6] >> 2;
    r[(int) j] = aux; j += 1;  // j = 11
    
    /* r[13 * i + 11]  =  (uint8_t) (t[6] >> 10);  */
    /* r[13 * i + 11] |=  (uint8_t) (t[7] <<  3);  */
    aux = t[6] >> 10; aux |= t[7] << 3;
    r[(int) j] = aux; j += 1; // j = 12
    
    /* r[13 * i + 12]  =  (uint8_t) (t[7] >>  5);  */
    aux = t[7] >> 5;
    r[(int)j] = aux; j += 1;  // j = 13
  }
  return r;
}

fn _polyt0_pack(reg ptr u8[POLYT0_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT0_PACKEDBYTES] {
  r = __polyt0_pack(r, a);
  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyt0_unpack
*
* Description: Unpack polynomial t0 with coefficients in ]-2^{D-1}, 2^{D-1}].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/
inline fn __polyt0_unpack(reg ptr u32[N] r, reg ptr u8[POLYT0_PACKEDBYTES] a) -> reg ptr u32[N] {
  reg u32 i, j, a_;
  reg u32[8] t;
  
  i = 0; j = 0;
  while(i < N) {
    /*  r->coeffs[8 * i + 0]  = a[13 * i + 0];
        r->coeffs[8 * i + 0] |= (uint32_t)a[13 * i + 1] << 8;
        r->coeffs[8 * i + 0] &= 0x1FFF; */
    t[0] = (32u) a[(int) j]; j += 1;  // j = 1
    a_ = (32u) a[(int) j]; j += 1;    // j = 2  a_ = a[1]
    t[0] |= a_ << 8;
    t[0] = #UBFX(t[0], 0, 13);
	
    t[0] = (1 << (D - 1)) - t[0];
    r[(int) i] = t[0]; i += 1;
	
    /*  r->coeffs[8 * i + 1]  = a[13 * i + 1] >> 5;
        r->coeffs[8 * i + 1] |= (uint32_t)a[13 * i + 2] << 3;
        r->coeffs[8 * i + 1] |= (uint32_t)a[13 * i + 3] << 11;
        r->coeffs[8 * i + 1] &= 0x1FFF; */
    t[1] = a_ >> 5;
    a_ = (32u) a[(int) j]; j += 1; // j = 3
    t[1] |= a_ << 3;
    a_ = (32u) a[(int) j]; j += 1; // j = 4 a_ = a[3]
    t[1] |= a_ << 11;
    t[1] = #UBFX(t[1], 0, 13);

    t[1] = (1 << (D - 1)) - t[1];
    r[(int) i] = t[1]; i += 1;
	
    /*  r->coeffs[8 * i + 2]  = a[13 * i + 3] >> 2;
        r->coeffs[8 * i + 2] |= (uint32_t)a[13 * i + 4] << 6;
        r->coeffs[8 * i + 2] &= 0x1FFF; */
    t[2] = a_ >> 2;
    a_ = (32u) a[(int) j]; j += 1;  // j = 5  a_ = a[4]
    t[2] |= a_ << 6;
    t[2] = #UBFX(t[2], 0, 13);
    
    t[2] = (1 << (D - 1)) - t[2];
    r[(int) i] = t[2]; i += 1;
	    
    /*  r->coeffs[8 * i + 3]  = a[13 * i + 4] >> 7;
        r->coeffs[8 * i + 3] |= (uint32_t)a[13 * i + 5] << 1;
        r->coeffs[8 * i + 3] |= (uint32_t)a[13 * i + 6] << 9;
        r->coeffs[8 * i + 3] &= 0x1FFF; */
    t[3] = a_ >> 7;
    a_ = (32u) a[(int) j]; j += 1;  // j = 6
    t[3] |= a_ << 1;
    a_ = (32u) a[(int) j]; j += 1; // j = 7 a_ = a[6]
    t[3] |= a_ << 9;
    t[3] = #UBFX(t[3], 0, 13);
    
    t[3] = (1 << (D - 1)) - t[3];
    r[(int) i] = t[3]; i += 1;
	
    /*  r->coeffs[8 * i + 4]  = a[13 * i + 6] >> 4;
        r->coeffs[8 * i + 4] |= (uint32_t)a[13 * i + 7] << 4;
        r->coeffs[8 * i + 4] |= (uint32_t)a[13 * i + 8] << 12;
        r->coeffs[8 * i + 4] &= 0x1FFF; */
    t[4] = a_ >> 4;
    a_ = (32u) a[(int) j]; j += 1;  // j = 8
    t[4] |=	a_ << 4;
    a_ = (32u) a[(int) j]; j += 1; // j = 9   a_ = a[8]
    t[4] |= a_ << 12;
    t[4] = #UBFX(t[4], 0, 13);
    
    t[4] = (1 << (D - 1)) - t[4];
    r[(int) i] = t[4]; i += 1;

	
    /*  r->coeffs[8 * i + 5]  = a[13 * i + 8] >> 1;
        r->coeffs[8 * i + 5] |= (uint32_t)a[13 * i + 9] << 7;
        r->coeffs[8 * i + 5] &= 0x1FFF; */
    t[5] = a_ >> 1;
    a_ = (32u) a[(int) j]; j += 1; // j = 10   a_ = a[9]
    t[5] |= a_ << 7;
    t[5] = #UBFX(t[5], 0, 13);

    t[5] = (1 << (D - 1)) - t[5];
    r[(int) i] = t[5]; i += 1;

    /*  r->coeffs[8 * i + 6]  = a[13 * i + 9] >> 6;
        r->coeffs[8 * i + 6] |= (uint32_t)a[13 * i + 10] << 2;
        r->coeffs[8 * i + 6] |= (uint32_t)a[13 * i + 11] << 10;
        r->coeffs[8 * i + 6] &= 0x1FFF; */
    t[6] = a_ >> 6;
    a_ = (32u) a[(int) j]; j += 1; // j = 11   a_ = a[10]
    t[6] |= a_ << 2;
    a_ = (32u) a[(int) j]; j += 1; // j = 12   a_ = a[11]
    t[6] |= a_ << 10;
    t[6] = #UBFX(t[6], 0, 13);
    
    t[6] = (1 << (D - 1)) - t[6];
    r[(int) i] = t[6]; i += 1;
	
    /*  r->coeffs[8 * i + 7]  = a[13 * i + 11] >> 3;
        r->coeffs[8 * i + 7] |= (uint32_t)a[13 * i + 12] << 5;
        r->coeffs[8 * i + 7] &= 0x1FFF; */
    t[7] = a_ >> 3;
    a_ = (32u) a[(int) j]; j += 1; // j = 13   a_ = a[12]
    t[7] |= a_ << 5;
    t[7] = #UBFX(t[7], 0, 13);

    t[7] = (1 << (D - 1)) - t[7];
    r[(int) i] = t[7]; i += 1;

    /* This is moved up */
    /*  r->coeffs[8 * i + 0] = (1 << (D - 1)) - r->coeffs[8 * i + 0];
        r->coeffs[8 * i + 1] = (1 << (D - 1)) - r->coeffs[8 * i + 1];
        r->coeffs[8 * i + 2] = (1 << (D - 1)) - r->coeffs[8 * i + 2];
        r->coeffs[8 * i + 3] = (1 << (D - 1)) - r->coeffs[8 * i + 3];
        r->coeffs[8 * i + 4] = (1 << (D - 1)) - r->coeffs[8 * i + 4];
        r->coeffs[8 * i + 5] = (1 << (D - 1)) - r->coeffs[8 * i + 5];
        r->coeffs[8 * i + 6] = (1 << (D - 1)) - r->coeffs[8 * i + 6];
        r->coeffs[8 * i + 7] = (1 << (D - 1)) - r->coeffs[8 * i + 7]; */


  }
  return r;
}

fn _polyt0_unpack(reg ptr u32[N] r, reg ptr u8[POLYT0_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyt0_unpack(r, a);
  return r;
}  

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyt1_pack
*
* Description: Bit-pack polynomial t1 with coefficients fitting in 10 bits.
*              Input coefficients are assumed to be standard representatives.
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYT1_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __polyt1_pack(reg ptr u8[POLYT1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT1_PACKEDBYTES] {
  reg u32 i, j, aux;
  reg u32[4] t;
  inline int k;
  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 4 {
      t[k] = a[(int) i]; i += 1;
    }
    /* r[5 * i + 0] = (uint8_t) (a->coeffs[4 * i + 0] >> 0); */
    r[(int) j] = t[0]; j += 1;
    
    /* r[5 * i + 1] = (uint8_t) ((a->coeffs[4 * i + 0] >> 8) | (a->coeffs[4 * i + 1] << 2)); */
    aux = t[0] >> 8; aux |= t[1] << 2;
    r[(int) j] = aux; j += 1;

    /* r[5 * i + 2] = (uint8_t) ((a->coeffs[4 * i + 1] >> 6) | (a->coeffs[4 * i + 2] << 4)); */
    aux = t[1] >> 6; aux |= t[2] << 4;
    r[(int) j] = aux; j += 1;

    /* r[5 * i + 3] = (uint8_t) ((a->coeffs[4 * i + 2] >> 4) | (a->coeffs[4 * i + 3] << 6)); */
    aux = t[2] >> 4; aux |= t[3] << 6;
    r[(int) j] = aux; j += 1;
    
    /* r[5 * i + 4] = (uint8_t) (a->coeffs[4 * i + 3] >> 2);                                 */
    aux = t[3] >> 2;
    r[(int) j] = aux; j += 1;
  }
  return r;
}

fn _polyt1_pack(reg ptr u8[POLYT1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT1_PACKEDBYTES] {
  r = __polyt1_pack(r, a);
  return r;
}	 

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyt1_unpack
*
* Description: Unpack polynomial t1 with 10-bit coefficients.
*              Output coefficients are standard representatives.
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/
inline fn __polyt1_unpack(reg ptr u32[N] r, reg ptr u8[POLYT1_PACKEDBYTES] a) -> reg ptr u32[N] {
  reg u32 i, j, aux;
  reg u32[5] t;
  inline int k;
  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 5 {
      t[k] = (32u) a[(int) j]; j += 1;
    }	
  
    /* r->coeffs[4 * i + 0] = ((a[5 * i + 0] >> 0) | ((uint32_t)a[5 * i + 1] << 8)) & 0x3FF; */
    aux = t[0] | (t[1] << 8); aux = #UBFX(aux, 0, 10);
    r[(int) i] = aux; i += 1;
  
    /* r->coeffs[4 * i + 1] = ((a[5 * i + 1] >> 2) | ((uint32_t)a[5 * i + 2] << 6)) & 0x3FF; */
    aux = t[1] >> 2; aux |= t[2] << 6; aux = #UBFX(aux, 0, 10);
    r[(int) i] = aux;	i += 1;
  
    /* r->coeffs[4 * i + 2] = ((a[5 * i + 2] >> 4) | ((uint32_t)a[5 * i + 3] << 4)) & 0x3FF; */
    aux = t[2] >> 4; aux |= t[3] << 4; aux = #UBFX(aux, 0, 10);
    r[(int) i] = aux; i += 1;
  
    /* r->coeffs[4 * i + 3] = ((a[5 * i + 3] >> 6) | ((uint32_t)a[5 * i + 4] << 2)) & 0x3FF; */
    aux = t[3] >> 6; aux |= t[4] << 2; aux = #UBFX(aux, 0, 10);
    r[(int) i] = aux; i += 1;
    
  }
  return r;
}

fn _polyt1_unpack(reg ptr u32[N] r, reg ptr u8[POLYT1_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyt1_unpack(r, a);
  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_use_hint
*
* Description: Use hint polynomial to correct the high bits of a polynomial.
*
* Arguments:   - poly *b: pointer to output polynomial with corrected high bits
*              - const poly *a: pointer to input polynomial
*              - const poly *h: pointer to input hint polynomial
**************************************************/
inline fn __poly_use_hint(reg ptr u32[N] b, reg ptr u32[N] a, reg ptr u32[N] h) -> reg ptr u32[N] {
  reg u32 i, b_, a_, h_, q;       

  q = __Q();
  i = 0;
  while(i < N) {
    a_ = a[(int) i];
    h_ = h[(int) i];
    b_ = __use_hint(a_, h_, q);
    b[(int) i] = b_;
    i += 1;
  }
  return b;
}

fn _poly_use_hint(reg ptr u32[N] b, reg ptr u32[N] a, reg ptr u32[N] h) -> reg ptr u32[N] {
  b = __poly_use_hint(b, a, h);
  return b;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyw1_pack
*
* Description: Bit-pack polynomial w1 with coefficients in [0,15] or [0,43].
*              Input coefficients are assumed to be standard representatives.
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYW1_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/

inline fn __polyw1_pack(reg ptr u8[POLYW1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYW1_PACKEDBYTES] {
  reg u32 i, j, aux;
  reg u32[2] t;
  inline int k;
  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 2 { t[k] = a[(int) i]; i += 1; }
    aux = t[0] | t[1] << 4;
    r[(int) j] = aux; j += 1;
  }
  return r;
}

fn _polyw1_pack(reg ptr u8[POLYW1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYW1_PACKEDBYTES] {
  r = __polyw1_pack(r, a);
  return r;
}


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyz_pack
*
* Description: Bit-pack polynomial with coefficients
*              in [-(GAMMA1 - 1), GAMMA1].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYZ_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __polyz_pack(reg ptr u8[POLYZ_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYZ_PACKEDBYTES] {
  reg u32 i, j, aux, gamma1;
  reg u32[2] t;
  inline int k;

  gamma1 = __GAMMA1();

  i = 0; j = 0;
  while (i < N) {
    for k = 0 to 2 {
       t[k] = a[(int) i]; t[k] = gamma1 - t[k];
       i += 1;
    }

    /* r[5 * i + 0]  = (uint8_t) t[0]; */
    r[(int) j] = t[0]; j += 1;
    
    /* r[5 * i + 1]  = (uint8_t) (t[0] >> 8); */
    aux = t[0] >> 8;
    r[(int) j] = aux; j += 1;
    
    /* r[5 * i + 2]  = (uint8_t) (t[0] >> 16); */
    /* r[5 * i + 2] |= (uint8_t) (t[1] << 4); */
    aux = t[0] >> 16; aux |= t[1] << 4;
    r[(int) j] = aux; j += 1;

    /* r[5 * i + 3]  = (uint8_t) (t[1] >> 4); */
    aux = t[1] >> 4;
    r[(int) j] = aux; j += 1;

    /* r[5 * i + 4]  = (uint8_t) (t[1] >> 12); */
    aux = t[1] >> 12;
    r[(int) j] = aux; j += 1;

  }
  return r;
}

fn _polyz_pack(reg ptr u8[POLYZ_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYZ_PACKEDBYTES] {
  r = __polyz_pack(r, a);
  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyz_unpack
*
* Description: Unpack polynomial z with coefficients
*              in [-(GAMMA1 - 1), GAMMA1].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/

inline fn __polyz_unpack(reg ptr u32[N] r, reg ptr u8[POLYZ_PACKEDBYTES] a) -> reg ptr u32[N] {
  reg u32 i, j, gamma1, aux;
  reg u32[5] t;
  inline int k;
  
  gamma1 = __GAMMA1();
  i = 0; j = 0;
  while(i < N) {
    for k = 0 to 5 { t[k] = (32u) a[(int) j]; j += 1; }
    
    /* r->coeffs[2 * i + 0]  = a[5 * i + 0];  
       r->coeffs[2 * i + 0] |= (uint32_t)a[5 * i + 1] << 8; 
       r->coeffs[2 * i + 0] |= (uint32_t)a[5 * i + 2] << 16; 
       r->coeffs[2 * i + 0] &= 0xFFFFF; */
    aux = t[0] | (t[1] << 8);
    aux |= t[2] << 16;
    aux = #UBFX(aux, 0, 20);
    aux = gamma1 - aux;
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[2 * i + 1]  = a[5 * i + 2] >> 4; */
    /* r->coeffs[2 * i + 1] |= (uint32_t)a[5 * i + 3] << 4; */
    /* r->coeffs[2 * i + 1] |= (uint32_t)a[5 * i + 4] << 12; */
    /* r->coeffs[2 * i + 0] &= 0xFFFFF; */  // this look like a lucky bug
    aux = t[2] >> 4;
    aux |= t[3] << 4;
    aux |= t[4] << 12;
    aux = gamma1 - aux;
    r[(int) i] = aux; i += 1;

    // Moved up
    /* r->coeffs[2 * i + 0] = GAMMA1 - r->coeffs[2 * i + 0]; */
    /* r->coeffs[2 * i + 1] = GAMMA1 - r->coeffs[2 * i + 1]; */
  }
  return r;
}

fn _polyz_unpack(reg ptr u32[N] r, reg ptr u8[POLYZ_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyz_unpack(r, a);
  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_uniform
*
* Description: Sample polynomial with uniformly random coefficients
*              in [0,Q-1] by performing rejection sampling on the
*              output stream of SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
*
* Arguments:   - poly *a: pointer to output polynomial
*              - const uint8_t seed[]: byte array with seed of length SEEDBYTES
*              - uint16_t nonce: 2-byte nonce
**************************************************/
inline fn __rej_sample(
  reg ptr u32[N] a, 
  reg u32 ctr, 
  reg u32 t, 
  reg u32 q
) -> reg ptr u32[N], reg u32 
{
  inline bool b;
  ?{"<u" = b} = #CMP(t, q);
  a[(int) ctr] = t if (b);
  ctr = ctr + 1 if (b);
  return a, ctr;
}

inline fn __extr_rej_sample(
  reg ptr u32[N] a, 
  reg u32 ctr, 
  reg u32 t, 
  reg u32 q
) -> reg ptr u32[N], reg u32 
{
  t = #UBFX(t,0, 23);
  a, ctr = __rej_sample(a, ctr, t, q);
  return a, ctr;
}

fn _poly_uniform(reg ptr u32[N] a,
                 reg ptr u8[SEEDBYTES] seed,
                 reg u32 nonce
) -> reg ptr u32[N]
{
  stack u32[25*2] state_;
  reg ptr u32[25*2] state;
  stack ptr u32[N] sa;
  sa = a; state = state_;
  state = _stream128_init(state, seed, nonce);
  a = sa;
  
  reg u32 ctr, ctr4, pos, q, t;
  reg u32[3] buf;

  ctr = 0; pos = 0; q = __Q();

  
  while { ctr4 = ctr + 4; } (ctr4 < N) {

    state, a, pos, ctr, q, buf = _stream128_refill_buffer(state, a, pos, ctr, q);

    a, ctr = __extr_rej_sample(a, ctr, buf[0], q);  // 3 bytes in buf[0]

    t = buf[0] >>u 24; t |= buf[1] << 8;    // 1 byte in buf[0] U 2 bytes in buf[1]
    a, ctr = __extr_rej_sample(a, ctr, t, q);

    t = buf[1] >>u 16; t |= buf[2] << 16;  // 2 byte in buf[1] U 1 bytes in buf[2]
    a, ctr = __extr_rej_sample(a, ctr, t, q);

    t = #UBFX(buf[2], 8, 23);
    a, ctr = __rej_sample(a, ctr, t, q);

  }

  while (ctr < N) {
    state, a, pos, ctr, q, buf = _stream128_refill_buffer(state, a, pos, ctr, q);

    a, ctr = __extr_rej_sample(a, ctr, buf[0], q);  // 3 bytes in buf[0]

    if (ctr < N) {
      t = buf[0] >>u 24; t |= buf[1] << 8;    // 1 byte in buf[0] U 2 bytes in buf[1]
      a, ctr = __extr_rej_sample(a, ctr, t, q);
    }

    if (ctr < N) {
      t = buf[1] >>u 16; t |= buf[2] << 16;  // 2 byte in buf[1] U 1 bytes in buf[2]
      a, ctr = __extr_rej_sample(a, ctr, t, q);
    }

    if (ctr < N) {
      t = #UBFX(buf[2], 8, 23);
      a, ctr = __rej_sample(a, ctr, t, q);
    }
  }
  return a;
} 

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_uniform_eta
*
* Description: Sample polynomial with uniformly random coefficients
*              in [-ETA,ETA] by performing rejection sampling on the
*              output stream from SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
*
* Arguments:   - poly *a: pointer to output polynomial
*              - const uint8_t seed[]: byte array with seed of length CRHBYTES
*              - uint16_t nonce: 2-byte nonce
**************************************************/

inline fn rej_eta(
  reg ptr u32[N] a, 
  reg u32 ctr, 
  reg u32 t,
  reg u32 n205
) -> reg ptr u32[N], reg u32 
{
  if (t < 15) {
    reg u32 aux;
    aux = t * n205;
    aux = aux >> 10;
    aux = aux + (aux << 2);  /* aux *= 5 */
    aux = t - aux;
    aux = 2 - aux;
    a[(int) ctr] = aux;
    ctr += 1;
  }
  return a, ctr;
}

fn _poly_uniform_eta(reg ptr u32[N] a,
                 reg ptr u8[CRHBYTES] seed,
                 reg u32 nonce
) -> reg ptr u32[N]
{
  stack u32[25*2] state_;
  reg ptr u32[25*2] state;
  stack ptr u32[N] sa;
  sa = a; state = state_;
  state = _stream256_init(state, seed, nonce);
  a = sa;
  
  reg u32 ctr, ctr8, pos, n205, t;
  reg u32 buf;

  ctr = 0; pos = 0; n205 = 205;

  while { ctr8 = ctr + 8; } (ctr8 < N) {

    state, a, pos, ctr, n205, buf = _stream256_refill_buffer(state, a, pos, ctr, n205);
    inline int i;
    for i = 0 to 8 {
      t = #UBFX(buf, 4*i, 4);
      a, ctr = rej_eta(a, ctr, t, n205);
    }     
  }

  while (ctr < N) {
    state, a, pos, ctr, n205, buf = _stream256_refill_buffer(state, a, pos, ctr, n205);
    inline int i;
    for i = 0 to 8 {
      if ((i == 0) || (ctr < N)) { 
        t = #UBFX(buf, 4*i, 4);
        a, ctr = rej_eta(a, ctr, t, n205);
      }
    }       
  } 
  return a;
} 

param int polyz_last = POLYZ_PACKEDBYTES / SHAKE256_RATE * SHAKE256_RATE;
param int polyz_last_sz = POLYZ_PACKEDBYTES % SHAKE256_RATE;


fn _poly_uniform_gamma1(reg ptr u32[N] a,
                 reg ptr u8[CRHBYTES] seed,
                 reg u32 nonce
) -> reg ptr u32[N]
{
  stack u8[POLYZ_PACKEDBYTES] buf_;
  reg ptr u8[POLYZ_PACKEDBYTES] buf;
  reg ptr u8[SHAKE256_RATE] bufb;
  stack u32[25*2] state_;
  reg ptr u32[25*2] state;
  stack ptr u32[N] sa;
  sa = a; state = state_;
  state = _stream256_init(state, seed, nonce);
  
  inline int k;
  for k = 0 to POLYZ_PACKEDBYTES / SHAKE256_RATE {
    bufb = buf_[SHAKE256_RATE * k : SHAKE256_RATE];
    bufb = _stream256_full_squeeze(bufb, state);
    buf_[SHAKE256_RATE * k : SHAKE256_RATE] = bufb;
    state = _keccakf1600_ref(state);
  }

  reg ptr u8[polyz_last_sz] bufc;
  bufc = buf_[ polyz_last : polyz_last_sz]; 

  reg u32 i, t;
  i = 0;
  while (i < polyz_last_sz / 4) {
    t = state[(int) i];
    bufc[u32 (int) i] = t;
    i += 1;
  }
  buf_[ polyz_last : polyz_last_sz] = bufc;

  buf = buf_; a = sa;
  a = _polyz_unpack(a, buf);
  return a;
}
