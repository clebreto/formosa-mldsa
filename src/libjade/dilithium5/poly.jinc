require "params.jinc"
require "rounding.jinc"
require "reduce.jinc"
require "ntt.jinc"

require "map.jinc"


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_reduce
*
* Description: Inplace reduction of all coefficients of polynomial to
*              representative in [-6283009,6283007].
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __map1__reduce32_8380417(a);
  return a;
}

fn _poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N] {
   a = __poly_reduce(a);
   return a; 
}


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_caddq
*
* Description: For all coefficients of in/out polynomial add Q if
*              coefficient is negative.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/

inline fn __poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __map1__caddq(a);
  return a;
}

fn _poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __poly_caddq(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_add
*
* Description: Add polynomials. No modular reduction is performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first summand
*              - const poly *b: pointer to second summand
**************************************************/

inline fn __poly_add_body(reg u32 coeff_a, reg u32 coeff_b) -> reg u32
{
  coeff_a = coeff_a + coeff_b;
  return coeff_a;
}

inline fn __poly_add_inplace(reg ptr u32[N] a b) -> reg ptr u32[N]
{
  reg u32 i coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_a = __poly_add_body(coeff_a, coeff_b);
    a[(int) i] = coeff_a;

    i += 1;
  }

  return a;
}

inline fn __poly_add(reg ptr u32[N] r a b) -> reg ptr u32[N]
{
  reg u32 i coeff_r coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_r = __poly_add_body(coeff_a, coeff_b);
    r[(int) i] = coeff_r;

    i += 1;
  }

  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_chknorm
*
* Description: Check infinity norm of polynomial against given bound.
*              Assumes input coefficients were reduced by PQCLEAN_DILITHIUM5_CLEAN_reduce32().
*
* Arguments:   - const poly *a: pointer to polynomial
*              - int32_t B: norm bound
*
* Returns 0 if norm is strictly smaller than B <= (Q-1)/8 and 1 otherwise.
**************************************************/

inline fn __poly_chknorm(reg ptr u32[N] a, reg u32 B) -> reg u32 {

  // TODO: to finish implementing
  
  reg u32 r;
  r = 0;
  
  // / 8 is a division by an immediate (should not be possible within the arm v7 ISA)
  reg u32 f;
  reg u32 div;

  f = Q;
  f -= 1;
  
  div = 8;
  reg u32 g;
  
  // TODO: division to handle
  //g = f / div;
 
  if (B > g) {
    r = 1;
  } else {
    reg u32 ai;
    reg u32 q s t u;
    reg u32 j;
    j = 2;
    reg u32 i;
    reg bool cond;
    cond = false;	

    i = 0;
    // TODO: add stop for r = 1
    while {
      ai = a[(int) i];
      q = j * ai;
      s = ai >> 31;
      u = s & q;
      t = ai - u;

      if (t >= B) {
         r = 1;
      }
      
      i += 1;
      
      // cond = (i < N && r != 1);
    } (i < N && r != 1);
  }
  
  return r; 
}

/*************************************************                                                         
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_decompose                                                     
*                                                                                                          
* Description: For all coefficients c of the input polynomial,                                             
*              compute high and low bits c0, c1 such c mod Q = c1*ALPHA + c0                               
*              with -ALPHA/2 < c0 <= ALPHA/2 except c1 = (Q-1)/ALPHA where we                              
*              set c1 = 0 and -ALPHA/2 <= c0 = c mod Q - Q < 0.                                            
*              Assumes coefficients to be standard representatives.                                        
*                                                                                                          
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1                               
*              - poly *a0: pointer to output polynomial with coefficients c0                               
*              - const poly *a: pointer to input polynomial                                                
**************************************************/
fn _poly_decompose (reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  reg u32 i;
  reg u32 q;

  q = __Q();

  i = 0;
  while (i < N) {
    reg u32 a0_, a1_, a_;
    a_ = a[(int) i];
    a0_, a1_ = __decompose_a0a1(a_, q);
    a0[(int) i] = a0_;
    a1[(int) i] = a1_;
    i += 1;
  }

  return a1, a0;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyeta_pack
*
* Description: Bit-pack polynomial with coefficients in [-ETA,ETA].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYETA_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/

inline fn __eta_minus_coeff(reg ptr u32[N] a, reg u32 i) -> reg u32 {
  reg u32 c;
  c = a[(int) i];
  c = ETA - c;
  return c;  
}

inline fn __polyeta_pack(reg ptr u8[POLYETA_PACKEDBYTES] r, reg ptr u32[N] a) ->
       reg ptr u8[POLYETA_PACKEDBYTES] {

  reg u32 i, j;
  reg u32[8] t;
  
  /*
  for (i = 0; i < N / 8; ++i) {
      t[0] = (uint8_t) (ETA - a->coeffs[8 * i + 0]);
      t[1] = (uint8_t) (ETA - a->coeffs[8 * i + 1]);
      t[2] = (uint8_t) (ETA - a->coeffs[8 * i + 2]);
      t[3] = (uint8_t) (ETA - a->coeffs[8 * i + 3]);
      t[4] = (uint8_t) (ETA - a->coeffs[8 * i + 4]);
      t[5] = (uint8_t) (ETA - a->coeffs[8 * i + 5]);
      t[6] = (uint8_t) (ETA - a->coeffs[8 * i + 6]);
      t[7] = (uint8_t) (ETA - a->coeffs[8 * i + 7]);
  
      r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
      r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
      r[3 * i + 2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
  }
  */
  
  i = 0; j = 0;
  while(i < N) {
    inline int k;
    for k = 0 to 8 {
      t[k] = __eta_minus_coeff(a, i);
      i += 1;
    }
    reg u32 aux;
    aux = t[0] | t[1] << 3;  aux |= t[2] << 6;
    r[(int) j] = aux; j += 1;
    aux = #UBFX(t[2], 2, 6); aux |= t[3] << 1; aux |= t[4] << 4; aux |= t[5] << 7;
    r[(int) j] = aux; j += 1;
    aux = #UBFX(t[5], 1, 7); aux |= t[6] << 2; aux |= t[7] << 5;
    r[(int) j] = aux; j += 1;
  }
  return r;
  
}

fn _polyeta_pack(reg ptr u8[POLYETA_PACKEDBYTES] r, reg ptr u32[N] a) ->
       reg ptr u8[POLYETA_PACKEDBYTES] {
   r = __polyeta_pack(r, a);
   return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyeta_unpack
*
* Description: Unpack polynomial with coefficients in [-ETA,ETA].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/

inline fn __polyeta_unpack(reg ptr u32[N] r, reg ptr u8[POLYETA_PACKEDBYTES] a) -> reg ptr u32[N] {

  reg u32 i, j;
  reg u32[3] t;
  inline int k;
  reg u32 aux;
  i = 0; j = 0;
  while(i < N) {
  
    for k = 0 to 3 { t[k] = (32u) a[(int) j]; j +=1; }
    
    /* r->coeffs[8 * i + 0] =  (a[3 * i + 0] >> 0) & 7;
       r->coeffs[8 * i + 0] = ETA - r->coeffs[8 * i + 0]; */
    aux = #UBFX(t[0], 0, 3); aux = ETA - aux;
    r[(int) i] = aux; i += 1; 
  
    /* r->coeffs[8 * i + 1] =  (a[3 * i + 0] >> 3) & 7;
       r->coeffs[8 * i + 1] = ETA - r->coeffs[8 * i + 1]; */
    aux = #UBFX(t[0], 3, 3); aux = ETA - aux; 
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 2] = ((a[3 * i + 0] >> 6) | (a[3 * i + 1] << 2)) & 7;
       r->coeffs[8 * i + 2] = ETA - r->coeffs[8 * i + 2]; */
    aux = t[0] >> 6; aux |= t[1] << 2; aux &= 7; aux = ETA - aux;
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 3] =  (a[3 * i + 1] >> 1) & 7;
       r->coeffs[8 * i + 3] = ETA - r->coeffs[8 * i + 3]; */
    aux = #UBFX(t[1], 1, 3); aux = ETA - aux;
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 4] =  (a[3 * i + 1] >> 4) & 7;
       r->coeffs[8 * i + 4] = ETA - r->coeffs[8 * i + 4]; */
    aux = #UBFX(t[1], 4, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 5] = ((a[3 * i + 1] >> 7) | (a[3 * i + 2] << 1)) & 7;
       r->coeffs[8 * i + 5] = ETA - r->coeffs[8 * i + 5]; */
    aux = t[1] >> 7; aux |= t[2] << 1; aux &= 7; aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 6] =  (a[3 * i + 2] >> 2) & 7;
       r->coeffs[8 * i + 6] = ETA - r->coeffs[8 * i + 6]; */
    aux = #UBFX(t[2], 2, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
    
    /* r->coeffs[8 * i + 7] =  (a[3 * i + 2] >> 5) & 7;
       r->coeffs[8 * i + 7] = ETA - r->coeffs[8 * i + 7]; */
    aux = #UBFX(t[2],5, 3); aux = ETA - aux;	
    r[(int) i] = aux; i += 1;
  }
  return r;  
}

fn _polyeta_unpack(reg ptr u32[N] r, reg ptr u8[POLYETA_PACKEDBYTES] a) -> reg ptr u32[N] {
  r = __polyeta_unpack(r, a);
  return r;
} 


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_ntt
*
* Description: Inplace forward NTT. Coefficients can grow by
*              8*Q in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_ntt(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __ntt(a);
  return a;
}

inline fn _poly_ntt(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = _ntt(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_invntt_tomont
*
* Description: Inplace inverse NTT and multiplication by 2^{32}.
*              Input coefficients need to be less than Q in absolute
*              value and output coefficients are again bounded by Q.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_invntt_tomont(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __invntt_tomont(a);    
  return a;
}

inline fn _poly_invntt_tomont(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = _invntt_tomont(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_pointwise_montgomery
*
* Description: Pointwise multiplication of polynomials in NTT domain
*              representation and multiplication of resulting polynomial
*              by 2^{-32}.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial
**************************************************/
inline fn __poly_pointwise_montgomery(reg ptr u32[N] c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  reg u32 i, a_, b_, c_;
  i = 0;
  while (i < N) {
    a_ = a[(int) i]; b_ = b[(int) i];
    c_ = __mul_montgomery_reduce_8380417(a_, b_);
    c[(int) i] = c_;
    i += 1;
  }
  return c;
}

fn _poly_pointwise_montgomery(reg ptr u32[N] c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
  c = __poly_pointwise_montgomery(c, a, b);
  return c;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_make_hint
*
* Description: Compute hint polynomial. The coefficients of which indicate
*              whether the low bits of the corresponding coefficient of
*              the input polynomial overflow into the high bits.
*
* Arguments:   - poly *h: pointer to output hint polynomial
*              - const poly *a0: pointer to low part of input polynomial
*              - const poly *a1: pointer to high part of input polynomial
*
* Returns number of 1 bits.
**************************************************/
/* FIXME: is it constant time? Check __make_hint */
inline fn __poly_make_hint(reg ptr u32[N] h, reg ptr u32[N] a0, reg ptr u32[N] a1) -> reg u32, reg ptr u32[N]{
  reg u32 i, s, a0_, a1_, h_, gamma2;
  gamma2 = __GAMMA2();
  i = 0; s = 0;
  while (i < N) {
    a0_ = a0[(int) i];
    a1_ = a1[(int) i];
    h_ = __make_hint(a0_, a1_, gamma2);
    h[(int) i] = h_; 
    s += h_;
    i += 1;	 
  }
  return s, h;
}

fn _poly_make_hint(reg ptr u32[N] h, reg ptr u32[N] a0, reg ptr u32[N] a1) -> reg u32, reg ptr u32[N] {
  reg u32 s;
  s, h = __poly_make_hint(h, a0, a1);
  return s, h;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_power2round
*
* Description: For all coefficients c of the input polynomial,
*              compute c0, c1 such that c mod Q = c1*2^D + c0
*              with -2^{D-1} < c0 <= 2^{D-1}. Assumes coefficients to be
*              standard representatives.
*
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
*              - poly *a0: pointer to output polynomial with coefficients c0
*              - const poly *a: pointer to input polynomial
**************************************************/
inline fn __poly_power2round(reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  reg u32 i, a_, a0_, a1_;
    
  i = 0;
  while (i < N) {
    a_ = a[(int) i];
    a0_, a1_ = __power2round_a0a1(a_);
    a0[(int) i] = a0_; a1[(int) i] = a1_;
    i += 1;	
  }
  return (a1, a0);
}

fn _poly_power2round(reg ptr u32[N] a1, reg ptr u32[N] a0, reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N] {
  a1, a0 = __poly_power2round(a1, a0, a);
  return (a1, a0);
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_shiftl
*
* Description: Multiply polynomial by 2^D without modular reduction. Assumes
*              input coefficients to be less than 2^{31-D} in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_shiftl(reg ptr u32[N] a) -> reg ptr u32[N] {
  reg u32 i, a_;
  
  i = 0;
  while (i < N) {
    a_ = a[(int) i];
    a_ <<= D;
    a[(int) i] = a_;
    i += 1;    
  }
  return a;
}

fn _poly_shiftl(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __poly_shiftl(a);
  return a;
}