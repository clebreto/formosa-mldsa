require "params.jinc"
require "rounding.jinc"
require "reduce.jinc"
require "ntt.jinc"

require "map.jinc"


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_reduce
*
* Description: Inplace reduction of all coefficients of polynomial to
*              representative in [-6283009,6283007].
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __map1__reduce32_8380417(a);
  return a;
}

fn _poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N] {
   a = __poly_reduce(a);
   return a; 
}


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_caddq
*
* Description: For all coefficients of in/out polynomial add Q if
*              coefficient is negative.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/

inline fn __poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __map1__caddq(a);
  return a;
}

fn _poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
  a = __poly_caddq(a);
  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_add
*
* Description: Add polynomials. No modular reduction is performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first summand
*              - const poly *b: pointer to second summand
**************************************************/

inline fn __poly_add_body(reg u32 coeff_a, reg u32 coeff_b) -> reg u32
{
  coeff_a = coeff_a + coeff_b;
  return coeff_a;
}

inline fn __poly_add_inplace(reg ptr u32[N] a b) -> reg ptr u32[N]
{
  reg u32 i coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_a = __poly_add_body(coeff_a, coeff_b);
    a[(int) i] = coeff_a;

    i += 1;
  }

  return a;
}

inline fn __poly_add(reg ptr u32[N] r a b) -> reg ptr u32[N]
{
  reg u32 i coeff_r coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_r = __poly_add_body(coeff_a, coeff_b);
    r[(int) i] = coeff_r;

    i += 1;
  }

  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_chknorm
*
* Description: Check infinity norm of polynomial against given bound.
*              Assumes input coefficients were reduced by PQCLEAN_DILITHIUM5_CLEAN_reduce32().
*
* Arguments:   - const poly *a: pointer to polynomial
*              - int32_t B: norm bound
*
* Returns 0 if norm is strictly smaller than B <= (Q-1)/8 and 1 otherwise.
**************************************************/

inline fn __poly_chknorm(reg ptr u32[N] a, reg u32 B) -> reg u32 {

  // TODO: to finish implementing
  
  reg u32 r;
  r = 0;
  
  // / 8 is a division by an immediate (should not be possible within the arm v7 ISA)
  reg u32 f;
  reg u32 div;

  f = Q;
  f -= 1;
  
  div = 8;
  reg u32 g;
  
  // TODO: division to handle
  //g = f / div;
 
  if (B > g) {
    r = 1;
  } else {
    reg u32 ai;
    reg u32 q s t u;
    reg u32 j;
    j = 2;
    reg u32 i;
    reg bool cond;
    cond = false;	

    i = 0;
    // TODO: add stop for r = 1
    while {
      ai = a[(int) i];
      q = j * ai;
      s = ai >> 31;
      u = s & q;
      t = ai - u;

      if (t >= B) {
         r = 1;
      }
      
      i += 1;
      
      // cond = (i < N && r != 1);
    } (i < N && r != 1);
  }
  
  return r; 
}
