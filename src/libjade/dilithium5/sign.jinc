require "packing.jinc"

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_keypair
*
* Description: Generates public and private key.
*
* Arguments:   - uint8_t *pk: pointer to output public key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES bytes)
*              - uint8_t *sk: pointer to output private key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES bytes)
*
* Returns 0 (success)
**************************************************/

fn shake256_PUBLICKEYBYTES_SEEDBYTES(reg ptr u8[SEEDBYTES] outp,
                                     reg ptr u8[ PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] inp) -> reg ptr u8[SEEDBYTES]
{ 
  stack u32[25*2] state;
  reg ptr u32[25*2] pstate;
  reg u32 i t s next;
  
  pstate = state;
  pstate = __keccak_init_ref(pstate);
  () = #spill(outp);
  reg u32 last;

  while {
    last = (PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES >> 2) - (SHAKE256_RATE >> 2);
  } 
  (i < last)
  { 
    next = i + (SHAKE256_RATE >> 2);
    while (i < next) { 
      t = inp[u32 (int)i];
      s = pstate[(int)i];
      t ^= s;
      pstate[(int)i] = t;
      i += 1;
    }
    () = #spill(i, inp);
    pstate = _keccakf1600_ref(pstate);
    () = #unspill(i, inp);
  }    

  while(i < (PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES >> 2)) {
    t = inp[u32 (int)i];
    s = pstate[(int)i];
    t ^= s;
    pstate[(int)i] = t;
    i += 1;
  }
  s = (32u)pstate[u8 (i * 4)];
  s ^= TRAIL_BYTE;
  pstate[u8 (i * 4)] = s;
  s = (32u) pstate[u8 (SHAKE256_RATE - 1)];
  s ^= 128;
  pstate[u8 (SHAKE256_RATE - 1)] = s;

  pstate = _keccakf1600_ref(pstate);
  
  () = #unspill(outp);
  i = 0;
  while (i < SEEDBYTES / 4) {
    t = pstate[(int)i];
    outp[(int)i] = t;
    i += 1;
  }   
  return outp;
}  
   


fn _crypto_sign_keypair_jazz(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES], reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES], reg u32 {
    reg u32 status;

    stack u8[SEEDBYTES] seedbuf, tr;
    stack u32[matKL] mat;
    stack u32[polyvecl] s1;
    stack u32[polyveck] s2, t1, t0;

    seedbuf = #randombytes(seedbuf);

    /****
    * Implements shake256(seedbuf, 2 * SEEDBYTES + CRHBYTES, seedbuf, SEEDBYTES);
    ****/
    stack u32[PQC_SHAKECTX_BYTES*2] state;
    reg ptr u32[PQC_SHAKECTX_BYTES*2] pstate;
    pstate = state;

    () = #spill(pk, sk);
    pstate = __SHAKE256_init_seed_ref(pstate, seedbuf);
    state = pstate;
    /***/

    reg ptr u8[SEEDBYTES] rho;
    rho = state[u8 0:SEEDBYTES];

    /* Expand matrix */
    mat = _polyvec_matrix_expand(mat, rho);

    reg ptr u8[CRHBYTES] rhoprime;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];

    reg u32 nonce;
    nonce = 0;
    /* Sample short vectors s1 and s2 */
    s1 = _polyvecl_uniform_eta(s1, rhoprime, nonce);
    nonce = L;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];
    s2 = _polyveck_uniform_eta(s2, rhoprime, nonce);

    /* Matrix-vector multiplication */
    s1 = _polyvecl_ntt(s1);
    t1 = _polyvec_matrix_pointwise_montgomery(t1, mat, s1);
    t1 = _polyveck_reduce(t1);
    t1 = _polyveck_invntt_tomont(t1);

    /* Add error vector s2 */
    t1 = _polyveck_add_inplace(t1, s2);

    /* Extract t1 and write public key */
    t1 = _polyveck_caddq(t1);
    t1, t0 = _polyveck_power2round_inplace(t1, t0);

    () = #unspill(pk);
    rho = state[u8 0:SEEDBYTES];
    //() = #spill(s1, s2);
    pk = _pack_pk(pk, rho, t1);

    /* Compute H(rho, t1) and write secret key */
    () = #spill(pk);    
    tr = shake256_PUBLICKEYBYTES_SEEDBYTES(tr, pk);
    () = #unspill(sk);
    reg ptr u8[SEEDBYTES] key;

    rho = state[u8 0:SEEDBYTES];
    key = state[u8 SEEDBYTES + CRHBYTES : SEEDBYTES];
    sk = _pack_sk(sk, rho, tr, key, t0, s1, s2);
    () = #unspill(pk);
    status = 1;

    return pk, sk, status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_signature
*
* Description: Computes signature.
*
* Arguments:   - uint8_t *sig:   pointer to output signature (of length PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES)
*              - size_t *siglen: pointer to output length of signature
*              - uint8_t *m:     pointer to message to be signed
*              - size_t mlen:    length of message
*              - uint8_t *sk:    pointer to bit-packed secret key
*
* Returns 0 (success)
**************************************************/
fn _crypto_sign_signature(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, reg u8 m, reg ptr u32[2] siglen_mlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES], reg u32 {
    sig = sig; siglen_mlen = siglen_mlen; sk = sk;
    reg u32 status; 
    status = -1;
    //TODO
    return sig, status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign
*
* Description: Compute signed message.
*
* Arguments:   - uint8_t *sm: pointer to output signed message (allocated
*                             array with PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES + mlen bytes),
*                             can be equal to m
*              - size_t *smlen: pointer to output length of signed
*                               message
*              - const uint8_t *m: pointer to message to be signed
*              - size_t mlen: length of message
*              - const uint8_t *sk: pointer to bit-packed secret key
*
* Returns 0 (success)
**************************************************/
fn _crypto_sign(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sm, reg u8 m, reg ptr u32[2] smlen_mlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES], reg u32 {
    reg u32 status;
    status = -1;
    //TODO
    return sm, status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_verify
*
* Description: Verifies signature.
*
* Arguments:   - uint8_t *m: pointer to input signature
*              - size_t siglen: length of signature
*              - const uint8_t *m: pointer to message
*              - size_t mlen: length of message
*              - const uint8_t *pk: pointer to bit-packed public key
*
* Returns 0 if signature could be verified correctly and -1 otherwise
**************************************************/
fn _crypto_sign_verify(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, reg u8 m, reg ptr u32[2] siglen_mlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
    sig = sig; m = m; siglen_mlen = siglen_mlen; pk = pk;
    reg u32 status;
    status = -1;
    //TODO
    return status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_open
*
* Description: Verify signed message.
*
* Arguments:   - uint8_t *m: pointer to output message (allocated
*                            array with smlen bytes), can be equal to sm
*              - size_t *mlen: pointer to output length of message
*              - const uint8_t *sm: pointer to signed message
*              - size_t smlen: length of signed message
*              - const uint8_t *pk: pointer to bit-packed public key
*
* Returns 0 if signed message could be verified correctly and -1 otherwise
**************************************************/
fn _crypto_sign_open(reg u32 pm, reg u32 sm, reg ptr u32[2] mlen_smlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
    reg u32 status;
    status = -1;
    //TODO
    return status;
}
