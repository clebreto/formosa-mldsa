require "packing.jinc"

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_keypair
*
* Description: Generates public and private key.
*
* Arguments:   - uint8_t *pk: pointer to output public key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES bytes)
*              - uint8_t *sk: pointer to output private key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES bytes)
*
* Returns 0 (success)
**************************************************/

fn _shake256_PUBLICKEYBYTES_SEEDBYTES(reg ptr u8[SEEDBYTES] outp,
                                     reg ptr u8[ PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] inp) -> reg ptr u8[SEEDBYTES]
{
  stack u32[25*2] state;
  reg ptr u32[25*2] pstate;
  reg u32 i j t s;
  
  pstate = state;
  pstate = __keccak_init_ref(pstate);
  () = #spill(outp);
  reg u32 last;

  i = 0;
  while {
    last = (PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES >> 2) - (SHAKE256_RATE >> 2);
  } 
  (i < last)
  { 
    j = 0;
    while (j < (SHAKE256_RATE >> 2)) { 
      t = inp[u32 (int)i];
      s = pstate[(int)j];
      t ^= s;
      pstate[(int)j] = t;
      i += 1;
      j += 1;
    }
    () = #spill(i, inp);
    pstate = _keccakf1600_ref(pstate);
    () = #unspill(i, inp);
  }    
  
  j = 0;
  while(i < (PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES >> 2)) {
    t = inp[u32 (int)i];
    s = pstate[(int)j];
    t ^= s;
    pstate[(int)j] = t;
    i += 1;
    j += 1;
  }

  /***
  *  FIXME : replace it by __add_block_end but warning 
  ***/
  s = (32u)pstate[u8 (j * 4)];
  s ^= TRAIL_BYTE;
  pstate[u8 (j * 4)] = s;
  s = (32u) pstate[u8 (SHAKE256_RATE - 1)];
  s ^= 128;
  pstate[u8 (SHAKE256_RATE - 1)] = s;

  pstate = _keccakf1600_ref(pstate);
  
  () = #unspill(outp);
  // FIXME this copy is not necessary if we return pstate, in that case it should be taken as argument
  i = 0;
  while (i < SEEDBYTES / 4) {
    t = pstate[(int)i];
    outp[u32 (int)i] = t;
    i += 1;
  }
  
  return outp;
} 

 

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_keypair_seed
*
* Description: Generates public and private key.
*
* Arguments:   - uint8_t *pk: pointer to output public key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES bytes)
*              - uint8_t *sk: pointer to output private key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES bytes)
*              - uint8_t *seed: pointer to input seed (allocated
*                             array of 2 * SEEDBYTES + CRHBYTES bytes)*
*
* Returns 0 (success)
**************************************************/
inline fn copy_polyvecl(reg ptr u32[polyvecl] s1hat, reg ptr u32[polyvecl] s1) -> reg ptr u32[polyvecl] {
    reg u32 i, t;

    i = 0;
    while (i < polyvecl) {
      t = s1[i];
      s1hat[i] = t;
      i += 1;
    }
    return s1hat;
}
    
/***
*  FIXME: share the code with next function 
***/
fn _crypto_sign_keypair_seed_jazz(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk, reg ptr u8[2 * SEEDBYTES + CRHBYTES] seedbuf) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES], reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES], reg u32 {
    reg u32 status;

    stack u8[SEEDBYTES] tr;
    stack u32[matKL] mat;
    stack u32[polyvecl] s1, s1hat;
    stack u32[polyveck] s2, t1, t0;

    /****
    * Implements shake256(seedbuf, 2 * SEEDBYTES + CRHBYTES, seedbuf, SEEDBYTES);
    ****/
    stack u32[PQC_SHAKECTX_BYTES*2] state;
    reg ptr u32[PQC_SHAKECTX_BYTES*2] pstate;
    pstate = state;

    reg ptr u8[32] pseedbuf;
    pseedbuf = seedbuf[0:SEEDBYTES];

    () = #spill(pk, sk);
    pstate = __SHAKE256_init_seed_ref(pstate, pseedbuf);
    state = pstate;
    /***/

    reg ptr u8[SEEDBYTES] rho;
    rho = state[u8 0:SEEDBYTES];

    /* Expand matrix */
    mat = _polyvec_matrix_expand(mat, rho);

    reg ptr u8[CRHBYTES] rhoprime;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];

    reg u32 nonce;
    nonce = 0;
    /* Sample short vectors s1 and s2 */
    s1 = _polyvecl_uniform_eta(s1, rhoprime, nonce);
    nonce = L;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];
    s2 = _polyveck_uniform_eta(s2, rhoprime, nonce);

    /* Matrix-vector multiplication */
    s1hat = copy_polyvecl(s1hat, s1);
    
    s1hat = _polyvecl_ntt(s1hat);    
    t1 = _polyvec_matrix_pointwise_montgomery(t1, mat, s1hat);
    t1 = _polyveck_reduce(t1);
    t1 = _polyveck_invntt_tomont(t1);

    /* Add error vector s2 */
    t1 = _polyveck_add_inplace(t1, s2);

    /* Extract t1 and write public key */
    t1 = _polyveck_caddq(t1);
    t1, t0 = _polyveck_power2round_inplace(t1, t0);

    () = #unspill(pk);
    rho = state[u8 0:SEEDBYTES];
    //() = #spill(s1, s2);
    pk = _pack_pk(pk, rho, t1);

    /* Compute H(rho, t1) and write secret key */
    () = #spill(pk);
    tr = _shake256_PUBLICKEYBYTES_SEEDBYTES(tr, pk);

    reg ptr u8[SEEDBYTES] key;
    rho = state[u8 0:SEEDBYTES];
    key = state[u8 SEEDBYTES + CRHBYTES : SEEDBYTES];
    
    () = #unspill(sk);
    sk = _pack_sk(sk, rho, tr, key, t0, s1, s2);
    () = #unspill(pk);
    
    status = 0;

    return pk, sk, status;
}

fn _crypto_sign_keypair_jazz(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES], reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES], reg u32 {
    reg u32 status;

    stack u8[SEEDBYTES] seedbuf, tr;
    stack u32[matKL] mat;
    stack u32[polyvecl] s1;
    stack u32[polyveck] s2, t1, t0;

    seedbuf = #randombytes(seedbuf);

    /****
    * Implements shake256(seedbuf, 2 * SEEDBYTES + CRHBYTES, seedbuf, SEEDBYTES);    
    * Remark we use directly state as destination instead of seedbuf.
    ****/
    stack u32[PQC_SHAKECTX_BYTES*2] state;
    reg ptr u32[PQC_SHAKECTX_BYTES*2] pstate;
    pstate = state;

    () = #spill(pk, sk);
    pstate = __SHAKE256_init_seed_ref(pstate, seedbuf);
    state = pstate;
    /***/

    reg ptr u8[SEEDBYTES] rho;
    rho = state[u8 0:SEEDBYTES];

    /* Expand matrix */
    mat = _polyvec_matrix_expand(mat, rho);

    reg ptr u8[CRHBYTES] rhoprime;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];

    reg u32 nonce;
    nonce = 0;
    /* Sample short vectors s1 and s2 */
    s1 = _polyvecl_uniform_eta(s1, rhoprime, nonce);
    nonce = L;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];
    s2 = _polyveck_uniform_eta(s2, rhoprime, nonce);

    /* Matrix-vector multiplication */
    s1 = _polyvecl_ntt(s1);
    t1 = _polyvec_matrix_pointwise_montgomery(t1, mat, s1);
    t1 = _polyveck_reduce(t1);
    t1 = _polyveck_invntt_tomont(t1);

    /* Add error vector s2 */
    t1 = _polyveck_add_inplace(t1, s2);

    /* Extract t1 and write public key */
    t1 = _polyveck_caddq(t1);
    t1, t0 = _polyveck_power2round_inplace(t1, t0);

    () = #unspill(pk);
    rho = state[u8 0:SEEDBYTES];
    //() = #spill(s1, s2);
    pk = _pack_pk(pk, rho, t1);

    /* Compute H(rho, t1) and write secret key */
    () = #spill(pk);    
    tr = _shake256_PUBLICKEYBYTES_SEEDBYTES(tr, pk);
    () = #unspill(sk);
    reg ptr u8[SEEDBYTES] key;

    rho = state[u8 0:SEEDBYTES];
    key = state[u8 SEEDBYTES + CRHBYTES : SEEDBYTES];
    sk = _pack_sk(sk, rho, tr, key, t0, s1, s2);
    () = #unspill(pk);
    
    status = 0;

    return pk, sk, status;
}

/***
* Precondition:
  - pos is a multiple of 4 
***/
fn _shake256_inc_absorb_mem
  (reg ptr u32[25*2] pstate, 
   reg u32 pos, 
   reg u32 m, 
   reg u32 mlen) -> reg ptr u32[25*2], reg u32
{
  reg u32 t s aux;
  aux = SHAKE256_RATE - pos;
  if (aux <= mlen) {
    while (pos < SHAKE256_RATE) { 
      t = (u32)[m];
      s = pstate.[pos];
      s ^= t;
      pstate.[pos] = s;
      pos += 4; m += 4;
      mlen -= 4;      
    } 
    while {
      () = #spill(m, mlen);
      pstate = _keccakf1600_ref(pstate);
      () = #unspill(m, mlen);
      pos = 0;
    } 
    // FIXME: it will be good to be able to write (SHAKE256_RATE < mlen)
    (mlen > SHAKE256_RATE) 
    {
      while (pos < SHAKE256_RATE) { 
        t = (u32)[m];
        s = pstate.[pos];
        s ^= t;
        pstate.[pos] = s;
        pos += 4; m += 4;
      }
      mlen -= SHAKE256_RATE;
    }
  }
  // Invariant mlen < SHAKE256_RATE - pos 
  while (mlen > 0) {
    t = (32u)(u8)[m];
    s = (32u)pstate[u8 pos];
    s ^= t;
    pstate[u8 pos] = s;
    pos += 1; m += 1; mlen -= 1;
  }
  return pstate, pos;
}

/***
* Precondition CRHBYTES should have been filled in pstate
* CRHBYTES + K * POLYW1_PACKEDBYTES is dividable by 4 and 136
***/
fn _shake256_inc_absorb_KPOLYW1_PACKEDBYTES 
  (reg ptr u32[25*2] pstate, 
   reg ptr u8[K * POLYW1_PACKEDBYTES] m
  ) -> reg ptr u32[25*2], reg u32
{
  reg u32 t s i pos;
  i = 0;
  pos = CRHBYTES;
  while (pos < SHAKE256_RATE) { 
    s = m.[u32 i];
    pstate.[pos] = s;
    pos += 4; i += 4;
  }


  while {
    () = #spill(m, i);
    pstate = _keccakf1600_ref(pstate);
    () = #unspill(m, i);
    pos = 0;      
  } 
  (i < K * POLYW1_PACKEDBYTES)
  {
    while (pos < SHAKE256_RATE) { 
      t = m.[u32 i];
      s = pstate.[pos];
      s ^= t;
      pstate.[pos] = s;
      pos += 4; i += 4;
    }
  }

  return pstate, pos;
}

/** FIXME : This is __add_block_end, but with "i" a reg **/
fn _shake256_inc_finalize(
   reg ptr u32[25*2] state, 
   reg u32 i
) -> reg ptr u32[25*2]
{
  reg u32 t0 t1;
  
  t0 = (32u) state[u8 (int)i];
  t0 ^= TRAIL_BYTE;
  state[u8 (int)i] = (8u) t0;

  t0 = (32u) state[u8 SHAKE256_RATE - 1];  
  t1 = 0x80;
  t0 ^= t1;
  state[u8 SHAKE256_RATE - 1] = (8u) t0;

  return state;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_signature
*
* Description: Computes signature.
*
* Arguments:   - uint8_t *sig:   pointer to output signature (of length PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES)
*              - size_t *siglen: pointer to output length of signature
*              - uint8_t *m:     pointer to message to be signed
*              - size_t mlen:    length of message
*              - uint8_t *sk:    pointer to bit-packed secret key
*
* Returns 0 (success)
**************************************************/
fn _crypto_sign_signature
  (reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, 
   reg u32 m, 
   reg ptr u32[2] siglen_mlen, 
   reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) 
   -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES], reg u32 
{
  sig = sig; siglen_mlen = siglen_mlen; sk = sk;
  reg u32 status; 
  stack u8[SEEDBYTES] s_rho, s_tr;
  stack u8[CRHBYTES] s_rhoprime;
  stack u32[polyveck] s_t0, s_s2;
  stack u32[polyvecl] s_s1;
  stack u8[SEEDBYTES + CRHBYTES] s_key_mu;

  reg ptr u8[SEEDBYTES] rho, tr, key;
  reg ptr u32[polyveck] t0, s2;
  reg ptr u32[polyvecl] s1;
  reg ptr u8[CRHBYTES] mu rhoprime;
  reg ptr u8[SEEDBYTES + CRHBYTES] key_mu;

  reg u32 pos mlen;
  inline int i;

  rho = s_rho; tr = s_tr; key = s_key_mu[0:SEEDBYTES];
  t0 = s_t0; s1 = s_s1; s2 = s_s2;

  () = #spill(sig, siglen_mlen, m);
  (rho, tr, key, t0, s1, s2) = _unpack_sk(rho, tr, key, t0, s1, s2, sk);
  s_rho = rho; s_tr = tr; s_t0 = t0; s_s1 = s1; s_s2 = s2;
  s_key_mu[0:SEEDBYTES] = key;
  /* Compute CRH(tr, msg) */
  
  stack u32[25*2] state;
  reg ptr u32[25*2] pstate;
  pstate = state;
  /***
  *  shake256_inc_init(&state);
  *  shake256_inc_absorb(&state, tr, SEEDBYTES);
  ***/
  pstate = __add_seed_ref(pstate, tr); 
  pstate = __add_zero_after_add(pstate, SEEDBYTES);
  () = #unspill(siglen_mlen, m);
  mlen = siglen_mlen[1];
  pos = SEEDBYTES;
  pstate, pos = _shake256_inc_absorb_mem(pstate, pos, m, mlen);
  pstate = _shake256_inc_finalize(pstate, pos);
  pstate = _keccakf1600_ref(pstate);
  // FIXME define a function for that
  mu = s_key_mu[SEEDBYTES : CRHBYTES];
  for i = 0 to CRHBYTES/4 {
    reg u32 t;
    t = pstate[i];
    mu[u32 i] = t;
  }
  s_key_mu[SEEDBYTES: CRHBYTES] = mu;
  
  // shake256(rhoprime, CRHBYTES, key, SEEDBYTES + CRHBYTES);
  key_mu = s_key_mu;
  pstate = __add_seedcrh_ref(pstate, key_mu);
  pstate = __add_zero_after_add(pstate, SEEDBYTES + CRHBYTES);
  pstate = __add_block_end(pstate, SEEDBYTES + CRHBYTES, SHAKE256_RATE);
  pstate = _keccakf1600_ref(pstate);
  state = pstate;
  rhoprime = s_rhoprime;
  for i = 0 to CRHBYTES/4 {
    reg u32 t;
    t = pstate[i];
    rhoprime[u32 i] = t;
  }
  s_rhoprime = rhoprime;
  

  stack u32[matKL] s_mat;
  stack u32[polyvecl] s_y, s_z;
  stack u32[polyveck] s_h;
  reg ptr u32[matKL] mat;
  reg ptr u32[polyvecl] y, z;
  reg ptr u32[polyveck] h;
  stack u32[polyveck] s_w1 s_w0;
  stack u32[N] s_cp; 
  reg ptr u32[polyveck] w1 w0;
  reg ptr u32[N] cp; 
  mat = s_mat; rho = s_rho;
  mat = _polyvec_matrix_expand(mat, rho); s_mat = mat;  
  s1 = s_s1; s1 = _polyvecl_ntt(s1); s_s1 = s1;
  s2 = s_s2; s2 = _polyveck_ntt(s2); s_s2 = s2;
  t0 = s_t0; t0 = _polyveck_ntt(t0); s_t0 = t0;

  reg u32 continue nonce r0;
  stack u32 s_nonce s_continue;
  r0 = 0;
  s_nonce = r0;

  while {
    /* Sample intermediate vector y */
    rhoprime = s_rhoprime; 
    nonce = s_nonce;
    s_y = _polyvecl_uniform_gamma1(s_y, rhoprime, nonce);
    nonce = s_nonce; nonce += 1; s_nonce = nonce;
    
    /* Matrix-vector multiplication */
    s_z = copy_polyvecl(s_z, s_y);
    s_z = _polyvecl_ntt(s_z);
    mat = s_mat;
    w1 = s_w1; w1 = _polyvec_matrix_pointwise_montgomery(w1, mat, s_z); 
    w1 = _polyveck_reduce(w1);
    w1 = _polyveck_invntt_tomont(w1);
  
    /* Decompose w and call the random oracle */
    w1 = _polyveck_caddq(w1);
    w0 = s_w0;
    w1, s_w0 = _polyveck_decompose_inplace(w1, w0);
    s_w1 = w1; 
    () = #unspill(sig);
    reg ptr u8[K * POLYW1_PACKEDBYTES] sig1;
    sig1 = sig[0: K * POLYW1_PACKEDBYTES];
    sig1 = _polyveck_pack_w1(sig1, w1);
    sig[0: K * POLYW1_PACKEDBYTES] = sig1;
    () = #spill(sig);
    // SHAKE256
    pstate = state; mu = s_key_mu[SEEDBYTES : CRHBYTES];
    pstate = __add_crh_ref(pstate, mu);
    pstate = __add_zero_after_add(pstate, CRHBYTES);
    pstate, pos = _shake256_inc_absorb_KPOLYW1_PACKEDBYTES(pstate, sig1);
    pstate = _shake256_inc_finalize(pstate, pos);
    pstate = _keccakf1600_ref(pstate);
    // FIXME define a function for that

    reg ptr u8[SEEDBYTES] sigseed;
    () = #unspill(sig);
    sigseed = sig[0:SEEDBYTES];
    for i = 0 to SEEDBYTES/4 {
      reg u32 t;
      t = pstate[i];
      sigseed[u32 i] = t;
    }
    state = pstate;
    sig[0:SEEDBYTES] = sigseed;
       
    () = #spill(sig);
    cp = s_cp;
    cp = _poly_challenge(cp, sigseed);
    cp = _poly_ntt(cp);
    /* Compute z, reject if it reveals secret */
    s1 = s_s1;
    s_z = _polyvecl_pointwise_poly_montgomery(s_z, cp, s1); s_cp = cp;
    s_z = _polyvecl_invntt_tomont(s_z);
    s_z = _polyvecl_add_inplace(s_z, s_y);
    s_z = _polyvecl_reduce(s_z);   
    
    reg u32 chknorm bound; 
    bound = iGAMMA1 - BETA;
    chknorm = _polyvecl_chknorm(s_z, bound);
    () = #spill(sig);    
    if (chknorm != 0) { 
      continue = 1;
    } else {
      s2 = s_s2; h = s_h;
      h = _polyveck_pointwise_poly_montgomery(h, cp, s2);
      h = _polyveck_invntt_tomont(h); s_h = h;
      w0 = s_w0;
      w0 = _polyveck_sub_inplace(w0, h);
      w0 = _polyveck_reduce(w0);
      s_w0 = w0;
      bound = iGAMMA2 - BETA;
      chknorm = _polyveck_chknorm(w0, bound);
      if (chknorm != 0) { 
        continue = 1;
      } else {
        cp = s_cp; t0 = s_t0;
        h = h;  // Needed for regalloc
        h = _polyveck_pointwise_poly_montgomery(h, cp, t0); 
        h = _polyveck_invntt_tomont(h); 
        h = h; // Needed for regalloc
        h = _polyveck_reduce(h); s_h = h;
   
        bound = iGAMMA2;
        chknorm = _polyveck_chknorm(h, bound);
        if (chknorm != 0) { 
          continue = 1;
        } else {
          w0 = s_w0;
          w0 = _polyveck_add_inplace(w0, h);
          s_w0 = w0; w1 = s_w1;
          reg u32 n;
          n, h = _polyveck_make_hint(h, w0, w1); s_h = h;
          if (n > OMEGA) { 
            continue = 1;
          } else {
            () = #unspill(sig);
            sig = _pack_sig_nocopy(sig, s_z, h);
            () = #spill(sig);
            continue  = 0;
          }
        }
      }
    }
  } (continue == 1)
  status = 0;
  () = #unspill(sig);
  return sig, status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign
*
* Description: Compute signed message.
*
* Arguments:   - uint8_t *sm: pointer to output signed message (allocated
*                             array with PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES + mlen bytes),
*                             can be equal to m
*              - size_t *smlen: pointer to output length of signed
*                               message
*              - const uint8_t *m: pointer to message to be signed
*              - size_t mlen: length of message
*              - const uint8_t *sk: pointer to bit-packed secret key
*
* Returns 0 (success)
**************************************************/
fn _crypto_sign(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sm, reg u8 m, reg ptr u32[2] smlen_mlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES], reg u32 {
    reg u32 status;
    status = -1;
    //TODO
    return sm, status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_verify
*
* Description: Verifies signature.
*
* Arguments:   - uint8_t *m: pointer to input signature
*              - size_t siglen: length of signature
*              - const uint8_t *m: pointer to message
*              - size_t mlen: length of message
*              - const uint8_t *pk: pointer to bit-packed public key
*
* Returns 0 if signature could be verified correctly and -1 otherwise
**************************************************/
fn _crypto_sign_verify(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, reg u32 m, reg u32 mlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
    reg u32 status;

    stack u8[SEEDBYTES] c, c2, rho;
    stack u8[CRHBYTES] mu;

    stack u32[polyvecl] z;
    stack u32[polyveck] h, w1, t1;
    stack u32[matKL] mat;
    stack u32[25*2] state;
    stack u32[N] cp;
    stack u8[K * POLYW1_PACKEDBYTES] buf;

    reg u32 pos;
    reg ptr u32[polyvecl] pz;

    inline int i;

    () = #spill(m, mlen);
    rho, t1 = _unpack_pk(rho, t1, pk);

    reg u32 ts;

    c, z, h, ts = _unpack_sig(c, z, h, sig);
    status = 0;

    if (ts == 1) { status = -1; }

    if (status == 0) {

      pz = z;
      //TOFIX
      // ts = _polyvecl_chknorm(pz, GAMMA1 - BETA);
      if (ts == 1) { status = -1; }

      if (status == 0) {
        mu[0:SEEDBYTES] = _shake256_PUBLICKEYBYTES_SEEDBYTES(mu[0:SEEDBYTES], pk);

        reg ptr u32[25*2] pstate;
        pstate = state;
        /***
        *  shake256_inc_init(&state);
        *  shake256_inc_absorb(&state, mu, SEEDBYTES);
        ***/
        pstate = __add_seed_ref(pstate, mu[0:SEEDBYTES]);
        pstate = __add_zero_after_add(pstate, SEEDBYTES);
//        () = #unspill(siglen_mlen, m);
        pos = SEEDBYTES;
        () = #unspill(m, mlen);
        pstate, pos = _shake256_inc_absorb_mem(pstate, pos, m, mlen);
        pstate = _shake256_inc_finalize(pstate, pos);
        pstate = _keccakf1600_ref(pstate);
        // FIXME define a function for that
        for i = 0 to CRHBYTES/4 {
          reg u32 t;
          t = pstate[i];
          mu[u32 i] = t;
        }
        state = pstate;

        // shake256_inc_init(&state);
        // shake256_inc_absorb(&state, mu, SEEDBYTES);
        // shake256_inc_absorb(&state, m, mlen);
        // shake256_inc_finalize(&state);
        // shake256_inc_squeeze(mu, CRHBYTES, &state);
        // shake256_inc_ctx_release(&state);

        cp = _poly_challenge(cp, c);
        mat = _polyvec_matrix_expand(mat, rho);

        z = _polyvecl_ntt(z);
        w1 = _polyvec_matrix_pointwise_montgomery(w1, mat, z);

        cp = _poly_ntt(cp);
        t1 =_polyveck_shiftl(t1);
        t1 = _polyveck_ntt(t1);
        // TOFIX need inplace
        //t1 = _polyveck_pointwise_poly_montgomery(t1, cp, t1);

        w1 = _polyveck_sub_inplace(w1, t1);
        w1 = _polyveck_reduce(w1);
        w1 = _polyveck_invntt_tomont(w1);


        w1 = _polyveck_caddq(w1);
        // TOFIX need inplace
        //w1 = _polyveck_use_hint(w1, w1, h);
        buf = _polyveck_pack_w1(buf, w1);

        //TODO
        /***
        *  shake256_inc_init(&state);
        *  shake256_inc_absorb(&state, mu, SEEDBYTES);
        ***/
        pstate = state;
        pstate = __add_crh_ref(pstate, mu);
        pstate = __add_zero_after_add(pstate, SEEDBYTES);
//        () = #unspill(siglen_mlen, m);
        pos = SEEDBYTES;
        () = #unspill(m, mlen);
        pstate, pos = _shake256_inc_absorb_mem(pstate, pos, m, mlen);
        pstate = _shake256_inc_finalize(pstate, pos);
        pstate = _keccakf1600_ref(pstate);
        // FIXME define a function for that
        for i = 0 to CRHBYTES/4 {
          reg u32 t;
          t = pstate[i];
          mu[u32 i] = t;
        }

        // shake256_inc_init(&state);
        // shake256_inc_absorb(&state, mu, CRHBYTES);
        // shake256_inc_absorb(&state, buf, K * POLYW1_PACKEDBYTES);
        // shake256_inc_finalize(&state);
        // shake256_inc_squeeze(c2, SEEDBYTES, &state);
        // shake256_inc_ctx_release(&state);


        // FIXME : must break early if needed
        //inline int i;
        //for i = 0 to SEEDBYTES {
        //  if (status == 0) {
        //    if (c[i] != c2[i]) {
        //      status = -1;
        //    }
        //  }
        //}
        status = 0;
      }
    }

    return status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_open
*
* Description: Verify signed message.
*
* Arguments:   - uint8_t *m: pointer to output message (allocated
*                            array with smlen bytes), can be equal to sm
*              - size_t *mlen: pointer to output length of message
*              - const uint8_t *sm: pointer to signed message
*              - size_t smlen: length of signed message
*              - const uint8_t *pk: pointer to bit-packed public key
*
* Returns 0 if signed message could be verified correctly and -1 otherwise
**************************************************/
fn _crypto_sign_open(reg u32 pm, reg u32 sm, reg ptr u32[2] mlen_smlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
    reg u32 status;
    status = -1;
    //TODO
    return status;
}
