require "packing.jinc"

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_keypair
*
* Description: Generates public and private key.
*
* Arguments:   - uint8_t *pk: pointer to output public key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES bytes)
*              - uint8_t *sk: pointer to output private key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES bytes)
*
* Returns 0 (success)
**************************************************/

fn shake256_PUBLICKEYBYTES_SEEDBYTES(reg ptr u8[SEEDBYTES] outp,
                                     reg ptr u8[ PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] inp) -> reg ptr u8[SEEDBYTES]
{ 
  stack u32[25*2] state;
  reg ptr u32[25*2] pstate;
  reg u32 i j t s next;
  
  pstate = state;
  pstate = __keccak_init_ref(pstate);
  () = #spill(outp);
  reg u32 last;

  while {
    last = (PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES >> 2) - (SHAKE256_RATE >> 2);
  } 
  (i < last)
  { 
    j = 0;
    while (j < (SHAKE256_RATE >> 2)) { 
      t = inp[u32 (int)i];
      s = pstate[(int)j];
      t ^= s;
      pstate[(int)j] = t;
      i += 1;
      j += 1;
    }
    () = #spill(i, inp);
    pstate = _keccakf1600_ref(pstate);
    () = #unspill(i, inp);
  }    
  
  j = 0;
  while(i < (PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES >> 2)) {
    t = inp[u32 (int)i];
    s = pstate[(int)j];
    t ^= s;
    pstate[(int)j] = t;
    i += 1;
    j += 1;
  }
  s = (32u)pstate[u8 (j * 4)];
  s ^= TRAIL_BYTE;
  pstate[u8 (j * 4)] = s;
  s = (32u) pstate[u8 (SHAKE256_RATE - 1)];
  s ^= 128;
  pstate[u8 (SHAKE256_RATE - 1)] = s;

  pstate = _keccakf1600_ref(pstate);
  
  () = #unspill(outp);
  // FIXME this copy is not necessary if we return pstate, in that case it should be taken as argument
  i = 0;
  while (i < SEEDBYTES / 4) {
    t = pstate[(int)i];
    outp[(int)i] = t;
    i += 1;
  }   
  return outp;
}  

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_keypair_seed
*
* Description: Generates public and private key.
*
* Arguments:   - uint8_t *pk: pointer to output public key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES bytes)
*              - uint8_t *sk: pointer to output private key (allocated
*                             array of PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES bytes)
*              - uint8_t *seed: pointer to input seed (allocated
*                             array of 2 * SEEDBYTES + CRHBYTES bytes)*
*
* Returns 0 (success)
**************************************************/

/***
*  FIXME: share the code with next function 
***/
fn _crypto_sign_keypair_seed_jazz(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk, reg ptr u8[2 * SEEDBYTES + CRHBYTES] seedbuf) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES], reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES], reg u32 {
    reg u32 status;

    stack u8[SEEDBYTES] tr;
    stack u32[matKL] mat;
    stack u32[polyvecl] s1;
    stack u32[polyveck] s2, t1, t0;

    /****
    * Implements shake256(seedbuf, 2 * SEEDBYTES + CRHBYTES, seedbuf, SEEDBYTES);
    ****/
    stack u32[PQC_SHAKECTX_BYTES*2] state;
    reg ptr u32[PQC_SHAKECTX_BYTES*2] pstate;
    pstate = state;

    reg ptr u8[32] pseedbuf;
    pseedbuf = seedbuf[0:SEEDBYTES];

    () = #spill(pk, sk);
    pstate = __SHAKE256_init_seed_ref(pstate, pseedbuf);
    state = pstate;
    /***/

    reg ptr u8[SEEDBYTES] rho;
    rho = state[u8 0:SEEDBYTES];

    /* Expand matrix */
    mat = _polyvec_matrix_expand(mat, rho);

    reg ptr u8[CRHBYTES] rhoprime;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];

    reg u32 nonce;
    nonce = 0;
    /* Sample short vectors s1 and s2 */
    s1 = _polyvecl_uniform_eta(s1, rhoprime, nonce);
    nonce = L;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];
    s2 = _polyveck_uniform_eta(s2, rhoprime, nonce);

    /* Matrix-vector multiplication */
    s1 = _polyvecl_ntt(s1);
    t1 = _polyvec_matrix_pointwise_montgomery(t1, mat, s1);
    t1 = _polyveck_reduce(t1);
    t1 = _polyveck_invntt_tomont(t1);

    /* Add error vector s2 */
    t1 = _polyveck_add_inplace(t1, s2);

    /* Extract t1 and write public key */
    t1 = _polyveck_caddq(t1);
    t1, t0 = _polyveck_power2round_inplace(t1, t0);

    () = #unspill(pk);
    rho = state[u8 0:SEEDBYTES];
    //() = #spill(s1, s2);
    pk = _pack_pk(pk, rho, t1);

    /* Compute H(rho, t1) and write secret key */
    () = #spill(pk);
    tr = shake256_PUBLICKEYBYTES_SEEDBYTES(tr, pk);
    () = #unspill(sk);
    reg ptr u8[SEEDBYTES] key;

    rho = state[u8 0:SEEDBYTES];
    key = state[u8 SEEDBYTES + CRHBYTES : SEEDBYTES];
    sk = _pack_sk(sk, rho, tr, key, t0, s1, s2);
    () = #unspill(pk);


    status = 0;

    return pk, sk, status;
}

fn _crypto_sign_keypair_jazz(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES], reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES], reg u32 {
    reg u32 status;

    stack u8[SEEDBYTES] seedbuf, tr;
    stack u32[matKL] mat;
    stack u32[polyvecl] s1;
    stack u32[polyveck] s2, t1, t0;

    seedbuf = #randombytes(seedbuf);

    /****
    * Implements shake256(seedbuf, 2 * SEEDBYTES + CRHBYTES, seedbuf, SEEDBYTES);    
    * Remark we use directly state as destination instead of seedbuf.
    ****/
    stack u32[PQC_SHAKECTX_BYTES*2] state;
    reg ptr u32[PQC_SHAKECTX_BYTES*2] pstate;
    pstate = state;

    () = #spill(pk, sk);
    pstate = __SHAKE256_init_seed_ref(pstate, seedbuf);
    state = pstate;
    /***/

    reg ptr u8[SEEDBYTES] rho;
    rho = state[u8 0:SEEDBYTES];

    /* Expand matrix */
    mat = _polyvec_matrix_expand(mat, rho);

    reg ptr u8[CRHBYTES] rhoprime;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];

    reg u32 nonce;
    nonce = 0;
    /* Sample short vectors s1 and s2 */
    s1 = _polyvecl_uniform_eta(s1, rhoprime, nonce);
    nonce = L;
    rhoprime = state[u8 SEEDBYTES:CRHBYTES];
    s2 = _polyveck_uniform_eta(s2, rhoprime, nonce);

    /* Matrix-vector multiplication */
    s1 = _polyvecl_ntt(s1);
    t1 = _polyvec_matrix_pointwise_montgomery(t1, mat, s1);
    t1 = _polyveck_reduce(t1);
    t1 = _polyveck_invntt_tomont(t1);

    /* Add error vector s2 */
    t1 = _polyveck_add_inplace(t1, s2);

    /* Extract t1 and write public key */
    t1 = _polyveck_caddq(t1);
    t1, t0 = _polyveck_power2round_inplace(t1, t0);

    () = #unspill(pk);
    rho = state[u8 0:SEEDBYTES];
    //() = #spill(s1, s2);
    pk = _pack_pk(pk, rho, t1);

    /* Compute H(rho, t1) and write secret key */
    () = #spill(pk);    
    tr = shake256_PUBLICKEYBYTES_SEEDBYTES(tr, pk);
    () = #unspill(sk);
    reg ptr u8[SEEDBYTES] key;

    rho = state[u8 0:SEEDBYTES];
    key = state[u8 SEEDBYTES + CRHBYTES : SEEDBYTES];
    sk = _pack_sk(sk, rho, tr, key, t0, s1, s2);
    () = #unspill(pk);
    
    status = 0;

    return pk, sk, status;
}

/***
* Precondition:
  - pos is a multiple of 4 
***/
fn _shake256_inc_absorb_mem
  (reg ptr u32[25*2] pstate, 
   reg u32 pos, 
   reg u32 m, 
   reg u32 mlen) -> reg ptr u32[25*2], reg u32
{
  reg u32 t s aux;
  aux = SHAKE256_RATE - pos;
  if (aux <= mlen) {
    while (pos < SHAKE256_RATE) { 
      t = (u32)[m];
      s = pstate.[pos];
      s ^= t;
      pstate.[pos] = s;
      pos += 4; m += 4;
      mlen -= 4;      
    } 
    while {
      () = #spill(m, mlen);
      pstate = _keccakf1600_ref(pstate);
      () = #unspill(m, mlen);
      pos = 0;
    } 
    // FIXME: it will be good to be able to write (SHAKE256_RATE < mlen)
    (mlen > SHAKE256_RATE) 
    {
      while (pos < SHAKE256_RATE) { 
        t = (u32)[m];
        s = pstate.[pos];
        s ^= t;
        pstate.[pos] = s;
        pos += 4; m += 4;
      }
      mlen -= SHAKE256_RATE;
    }
  }
  // Invariant mlen < SHAKE256_RATE - pos 
  while (mlen > 0) {
    t = (32u)(u8)[m];
    s = (32u)pstate[u8 pos];
    s ^= t;
    pstate[u8 pos] = s;
    pos += 1; m += 1; mlen -= 1;
  }
  return pstate, pos;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_signature
*
* Description: Computes signature.
*
* Arguments:   - uint8_t *sig:   pointer to output signature (of length PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES)
*              - size_t *siglen: pointer to output length of signature
*              - uint8_t *m:     pointer to message to be signed
*              - size_t mlen:    length of message
*              - uint8_t *sk:    pointer to bit-packed secret key
*
* Returns 0 (success)
**************************************************/
fn _crypto_sign_signature
  (reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, 
   reg u32 m, 
   reg ptr u32[2] siglen_mlen, 
   reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) 
   -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES], reg u32 
{
  sig = sig; siglen_mlen = siglen_mlen; sk = sk;
  reg u32 status; 
  stack u8[SEEDBYTES] s_rho, s_rhoprime, s_tr, s_key;
  stack u32[polyveck] s_t0, s_s2;
  stack u32[polyvecl] s_s1;

  reg ptr u8[SEEDBYTES] rho, rhoprime, tr, key;
  reg ptr u32[polyveck] t0, s2;
  reg ptr u32[polyvecl] s1;

  reg u32 pos mlen;

  rho = s_rho; tr = s_tr; key = s_key;
  t0 = s_t0; s1 = s_s1; s2 = s_s2;

  () = #spill(sig, siglen_mlen, m);
  (rho, tr, key, t0, s1, s2) = _unpack_sk(rho, tr, key, t0, s1, s2, sk);
  /* Compute CRH(tr, msg) */
  
  stack u32[25*2] state;
  reg ptr u32[25*2] pstate;
  pstate = state;
  /***
  *  shake256_inc_init(&state);
  *  shake256_inc_absorb(&state, tr, SEEDBYTES);
  ***/
  pstate = __add_seed_ref(pstate, tr); 
  pstate = __add_zero_after_add(pstate, SEEDBYTES);
  reg u32 pos;
  () = #unspill(siglen_mlen, m);
  mlen = siglen_mlen[1];
  pos = SEEDBYTES;
  pstate, pos = _shake256_inc_absorb_mem(pstate, pos, m, mlen);

  status = 1;
  //TODO
  () = #unspill(sig);
  return sig, status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign
*
* Description: Compute signed message.
*
* Arguments:   - uint8_t *sm: pointer to output signed message (allocated
*                             array with PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES + mlen bytes),
*                             can be equal to m
*              - size_t *smlen: pointer to output length of signed
*                               message
*              - const uint8_t *m: pointer to message to be signed
*              - size_t mlen: length of message
*              - const uint8_t *sk: pointer to bit-packed secret key
*
* Returns 0 (success)
**************************************************/
fn _crypto_sign(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sm, reg u8 m, reg ptr u32[2] smlen_mlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES], reg u32 {
    reg u32 status;
    status = -1;
    //TODO
    return sm, status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_verify
*
* Description: Verifies signature.
*
* Arguments:   - uint8_t *m: pointer to input signature
*              - size_t siglen: length of signature
*              - const uint8_t *m: pointer to message
*              - size_t mlen: length of message
*              - const uint8_t *pk: pointer to bit-packed public key
*
* Returns 0 if signature could be verified correctly and -1 otherwise
**************************************************/
fn _crypto_sign_verify(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, reg u8 m, reg ptr u32[2] siglen_mlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
    sig = sig; m = m; siglen_mlen = siglen_mlen; pk = pk;
    reg u32 status;
    status = -1;
    //TODO
    return status;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_crypto_sign_open
*
* Description: Verify signed message.
*
* Arguments:   - uint8_t *m: pointer to output message (allocated
*                            array with smlen bytes), can be equal to sm
*              - size_t *mlen: pointer to output length of message
*              - const uint8_t *sm: pointer to signed message
*              - size_t smlen: length of signed message
*              - const uint8_t *pk: pointer to bit-packed public key
*
* Returns 0 if signed message could be verified correctly and -1 otherwise
**************************************************/
fn _crypto_sign_open(reg u32 pm, reg u32 sm, reg ptr u32[2] mlen_smlen, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
    reg u32 status;
    status = -1;
    //TODO
    return status;
}
