require "poly.jinc"

param int polyvecl = N * L;
param int polyveck = N * K;
param int matKL = polyvecl * K;

/**************************************************************/
/************ Vectors of polynomials of length L **************/
/**************************************************************/

fn _polyvecl_uniform_eta(
  reg ptr u32[polyvecl] v, 
  reg ptr u8[CRHBYTES] seed, 
  reg u32 nonce
) -> reg ptr u32[polyvecl]
{
  inline int i;
  stack ptr u8[CRHBYTES] s_seed;
  stack ptr u32[polyvecl] s_v;
  stack u32 s_nonce;
  reg ptr u32[N] p;

  for i = 0 to L {
    p = v[i * N : N]; 
    s_v = v; s_nonce = nonce; s_seed = seed;
    p = _poly_uniform_eta(p, seed, nonce);
    s_v[i * N : N] = p; v = s_v;  nonce = s_nonce; seed = s_seed; 
    nonce += 1;

  }
  return v;
}

fn _polyvecl_uniform_gamma1(
  reg ptr u32[polyvecl] v, 
  reg ptr u8[CRHBYTES] seed, 
  reg u32 nonce
) -> reg ptr u32[polyvecl]
{
  inline int i;
  stack ptr u8[CRHBYTES] s_seed;
  stack ptr u32[polyvecl] s_v;
  stack u32 s_nonce;
  reg ptr u32[N] p;

  reg u32 l;
  l = L;
  nonce = l * nonce;
  nonce = #UBFX(nonce, 0, 16);
  for i = 0 to L {
    p = v[i * N : N]; 
    s_v = v; s_nonce = nonce; s_seed = seed;
    p = _poly_uniform_gamma1(p, seed, nonce);
    s_v[i * N : N] = p; v = s_v;  nonce = s_nonce; seed = s_seed;
    nonce += 1; nonce = #UBFX(nonce, 0, 16);

  }
  return v;
}

/* Start here */

fn _polyvecl_reduce(reg ptr u32[polyvecl] v) -> reg ptr u32[polyvecl] 
{
  inline int i;
  reg ptr u32[N] pv;
  for i = 0 to L {
    pv = v[i * N : N];
    v[i * N : N] = _poly_reduce(pv);
  }
  return v;
}

fn _polyvecl_add(
  reg ptr u32[polyvecl] w,
  reg ptr u32[polyvecl] u,
  reg ptr u32[polyvecl] v
) -> reg ptr u32[polyvecl] 
{
  inline int i;
  reg ptr u32[N] pw pu pv;
  for i = 0 to L {
    pw = w[i * N : N]; pu = u[i * N : N]; pv = v[i * N : N];
    w[i * N : N] = _poly_add(pw, pu, pv);
  }
  return w;
}

fn _polyvecl_ntt(reg ptr u32[polyvecl] v) -> reg ptr u32[polyvecl] 
{
  inline int i;
  reg ptr u32[N] pv;
  for i = 0 to L {
    pv = v[i * N : N];
    v[i * N : N] = _poly_ntt(pv);
  }
  return v;
}

fn _polyvecl_invntt_tomont(reg ptr u32[polyvecl] v) -> reg ptr u32[polyvecl] 
{
  inline int i;
  reg ptr u32[N] pv;
  for i = 0 to L {
    pv = v[i * N : N];
    v[i * N : N] = _poly_invntt_tomont(pv);
  }
  return v;
}

fn _polyvecl_pointwise_montgomery(
  reg ptr u32[polyvecl] r,
  reg ptr u32[N] a,
  reg ptr u32[polyvecl] v
) -> reg ptr u32[polyvecl] 
{
  inline int i;
  reg ptr u32[N] pr pv;
  for i = 0 to L {
    pr = r[i * N : N]; pv = v[i * N : N];
    r[i * N: N] = _poly_pointwise_montgomery(pr, a, pv);
  }
  return r;
}

fn _polyvecl_pointwise_acc_montgomery(
  reg ptr u32[N] w,
  reg ptr u32[polyvecl] u,
  reg ptr u32[polyvecl] v
) -> reg ptr u32[N] 
{
  inline int i;
  stack u32[N] st;
  reg ptr u32[N] t;
  reg ptr u32[N] pu pv;
  t = w;
  pu = u[0 : N]; pv = v[0 : N];
  t = _poly_pointwise_montgomery(t, pu, pv);
  w = t;
  t = st;
  for i = 1 to L {
    pu = u[i * N : N]; pv = v[i * N : N];
    t = _poly_pointwise_montgomery(t, pu, pv);
    w = _poly_add_inplace(w, t);
  }
  return w;
}

fn _polyvecl_chknorm(reg ptr u32[polyvecl] v, reg u32 bound) -> reg u32
{
  inline int i;
  reg u32 b b_; 
  reg ptr u32[N] pv;
  /* FIXME: due to sub array access we need to use a for loop,
     a while loop will allow to exists early */
  b = 0;   
  for i = 0 to L {
    pv = v[i * N : N];
    b_ = _poly_chknorm(pv, bound);
    b |= b_;
  }
  return b;
}

/**************************************************************/
/************ Vectors of polynomials of length K **************/
/**************************************************************/

fn _polyveck_uniform_eta(
  reg ptr u32[polyveck] v, 
  reg ptr u8[CRHBYTES] seed, 
  reg u32 nonce
) -> reg ptr u32[polyveck]
{
  inline int i;
  stack ptr u8[CRHBYTES] s_seed;
  stack ptr u32[polyveck] s_v;
  stack u32 s_nonce;
  reg ptr u32[N] p;

  for i = 0 to K {
    p = v[i * N : N]; 
    s_v = v; s_nonce = nonce; s_seed = seed;
    p = _poly_uniform_eta(p, seed, nonce);
    s_v[i * N : N] = p; v = s_v;  nonce = s_nonce; seed = s_seed; 
    nonce += 1;

  }
  return v;
}

fn _polyveck_reduce(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pv;
  for i = 0 to K {
    pv = v[i * N : N];
    v[i * N : N] = _poly_reduce(pv);
  }
  return v;
}

fn _polyveck_caddq(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pv;
  for i = 0 to K {
    pv = v[i * N : N];
    v[i * N : N] = _poly_caddq(pv);
  }
  return v;
}

fn _polyveck_add(
  reg ptr u32[polyveck] w,
  reg ptr u32[polyveck] u,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pw pu pv;
  for i = 0 to K {
    pw = w[i * N : N]; pu = u[i * N : N]; pv = v[i * N : N];
    w[i * N : N] = _poly_add(pw, pu, pv);
  }
  return w;
}

fn _polyveck_sub(
  reg ptr u32[polyveck] w,
  reg ptr u32[polyveck] u,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pw pu pv;
  for i = 0 to K {
    pw = w[i * N : N]; pu = u[i * N : N]; pv = v[i * N : N];
    w[i * N : N] = _poly_sub(pw, pu, pv);
  }
  return w;
}

fn _polyveck_shiftl(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pv;
  for i = 0 to K {
    pv = v[i * N : N];
    v[i * N : N] = _poly_shiftl(pv);
  }
  return v;
}

fn _polyveck_ntt(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pv;
  stack ptr u32[polyveck] sv;
  for i = 0 to K {
    pv = v[i * N : N]; sv = v;
    sv[i * N : N] = _poly_ntt(pv);
    v = sv;
  }
  return v;
}

fn _polyveck_invntt_tomont(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pv;
  stack ptr u32[polyveck] sv;
  for i = 0 to K {
    pv = v[i * N : N]; sv = v;
    sv[i * N : N] = _poly_invntt_tomont(pv);
    v = sv;
  }
  return v;
}

fn _polyveck_pointwise_montgomery(
  reg ptr u32[polyveck] r,
  reg ptr u32[N] a,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pr pv ;
  for i = 0 to K {
    pr = r[i * N : N]; pv = v[i * N : N];
    r[i * N: N] = _poly_pointwise_montgomery(pr, a, pv);
  }
  return r;
}

fn _polyveck_chknorm(reg ptr u32[polyveck] v, reg u32 bound) -> reg u32
{
  inline int i;
  reg u32 b b_; 
  reg ptr u32[N] pv;
  /* FIXME: due to sub array access we need to use a for loop,
     a while loop will allow to exists early */
  b = 0;   
  for i = 0 to K {
    pv = v[i * N : N];
    b_ = _poly_chknorm(pv, bound);
    b |= b_;
  }
  return b;
}

fn _polyveck_power2round(
  reg ptr u32[polyveck] v1,
  reg ptr u32[polyveck] v0,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck], reg ptr u32[polyveck]
{
  inline int i;
  reg ptr u32[N] pv1 pv0 pv;
  for i = 0 to K {
    pv1 = v1[i * N : N]; pv0 = v0[i * N : N]; pv = v[i * N : N];
    v1[i * N : N], v0[i * N : N] = _poly_power2round(pv1, pv0, pv);
  }
  return v1, v0;
}

fn _polyveck_decompose(
  reg ptr u32[polyveck] v1,
  reg ptr u32[polyveck] v0,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck], reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pv1 pv0 pv;
  for i = 0 to K {
    pv1 = v1[i * N : N]; pv0 = v0[i * N : N]; pv = v[i * N : N];
    v1[i * N : N], v0[i * N : N] = _poly_decompose(pv1, pv0, pv);
  }
  return v1, v0;
}

fn _polyveck_use_hint(
  reg ptr u32[polyveck] w,
  reg ptr u32[polyveck] u,
  reg ptr u32[polyveck] h
) -> reg ptr u32[polyveck] 
{
  inline int i;
  reg ptr u32[N] pw pu ph;
  for i = 0 to K {
    pw = w[i * N : N]; pu = u[i * N : N]; ph = h[i * N : N];
    w[i * N : N] = _poly_use_hint(pw, pu, ph);
  }
  return w;
}

fn _polyveck_pack_w1(
  reg ptr u8[K * POLYW1_PACKEDBYTES] r,
  reg ptr u32[polyveck] w1
) -> reg ptr u8[K * POLYW1_PACKEDBYTES] 
{
  inline int i;
  reg ptr u8[POLYW1_PACKEDBYTES] pr;
  reg ptr u32[N] pw1;
  for i = 0 to K {
    pr = r[i * POLYW1_PACKEDBYTES : POLYW1_PACKEDBYTES]; pw1 = w1[i * N : N];
    r[i * POLYW1_PACKEDBYTES : POLYW1_PACKEDBYTES] = _polyw1_pack(pr, pw1);
  }
  return r;
}



