require "params.jinc"

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_power2round
*
* Description: For finite field element a, compute a0, a1 such that
*              a mod^+ Q = a1*2^D + a0 with -2^{D-1} < a0 <= 2^{D-1}.
*              Assumes a to be standard representative.
*
* Arguments:   - int32_t a: input element
*              - int32_t *a0: pointer to output element a0
*
* Returns a1.
**************************************************/
inline fn __power2round_a0a1(reg u32 a) -> reg u32, reg u32 
{
  reg u32 a0 a1;
  reg u32 temp;
  temp = ((1 << (D - 1)) - 1);
  a1 = a + temp;
  a1 = a1 >>s D;
  temp = (a1 << D);
  a0 = a - temp;
  return (a0, a1);     
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_decompose
*
* Description: For finite field element a, compute high and low bits a0, a1 such
*              that a mod^+ Q = a1*ALPHA + a0 with -ALPHA/2 < a0 <= ALPHA/2 except
*              if a1 = (Q-1)/ALPHA where we set a1 = 0 and
*              -ALPHA/2 <= a0 = a mod^+ Q - Q < 0. Assumes a to be standard
*              representative.
*
* Arguments:   - int32_t a: input element
*              - int32_t *a0: pointer to output element a0
*
* Returns a1.
**************************************************/
// precondition q = Q
inline fn __decompose_a0a1(reg u32 a q) -> reg u32, reg u32
{
  reg u32 a0 a1 aux temp;
  
  /* a1  = (a + 127) >> 7; */
  a1 =  a + 127;
  a1 >>s= 7;
  
  /* a1  = (a1 * 1025 + (1 << 21)) >> 22;
     a1 &= 15; */

  temp = (a1 << 10);
  aux = a1 + temp; // aux = a1 * 1025;
  temp = 1 << 21;
  aux += temp;
  // a1 = #UBFX(aux, 22, 4);
  a1 = #SLLI(aux, 6); // RISCV 32 - (22 + 4) = 6
  a1 = #SRLI(a1, 28); // RISCV 32 - 4 = 28

  /* *a0  = a - a1 * 2 * GAMMA2; */
  /* - 2*GAMMA2 = (1 - 2 ^ 10) * 2^9 */
  temp = (a1 << 10);
  aux = a1 - temp;
  temp = (aux << 9);
  a0 = a + temp;
  
  /* *a0 -= (((Q - 1) / 2 - *a0) >> 31) & Q; */
  /* (Q - 1) / 2 = 1023 * 2^12 */
  aux = 1023;
  // (Q - 1) / 2 - *a0
  // aux = #RSB(a0, aux << 12); // ARM
  aux = aux << 12; // RISCV
  aux = aux - a0; // RISCV

  temp = (aux >>s 31);
  aux = q & temp;
  a0 -= aux;
  
  return a0, a1;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_make_hint
*
* Description: Compute hint bit indicating whether the low bits of the
*              input element overflow into the high bits.
*
* Arguments:   - int32_t a0: low bits of input element
*              - int32_t a1: high bits of input element
*
* Returns 1 if overflow.
**************************************************/
/*
unsigned int PQCLEAN_DILITHIUM5_CLEAN_make_hint(int32_t a0, int32_t a1) {
    if (a0 > GAMMA2 || a0 < -GAMMA2 || (a0 == -GAMMA2 && a1 != 0)) {
        return 1;
    }

    return 0;
}
*/

// gamma2 = GAMMA2
inline fn __make_hint(reg u32 a0, reg u32 a1, reg u32 gamma2) -> reg u32
{
   reg u32 mgamma2 res;
   inline bool lt eq;

   res = 1;
   if (a0 <=s gamma2) {
     mgamma2 = -gamma2;
     // ?{"==" = eq, "<s" = lt} = #CMP(a0,mgamma2);
     eq = (a0 == mgamma2);
     lt = (a0 <s mgamma2);

     if (!lt) {

      if (!eq) {
         res = 0;
      }

      if (a1 == 0) {
         res = 0;
       }

     }
   }
   return res;
}          




/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_use_hint
*
* Description: Correct high bits according to hint.
*
* Arguments:   - int32_t a: input element
*              - unsigned int hint: hint bit
*
* Returns corrected high bits.
**************************************************/
/*
int32_t PQCLEAN_DILITHIUM5_CLEAN_use_hint(int32_t a, unsigned int hint) {
    int32_t a0, a1;

    a1 = PQCLEAN_DILITHIUM5_CLEAN_decompose(&a0, a);
    if (hint == 0) {
        return a1;
    }

    if (a0 > 0) {
        return (a1 + 1) & 15;
    }
    return (a1 - 1) & 15;
}
*/

// Precondition q = Q
inline fn __use_hint(reg u32 a, reg u32 hint, reg u32 q) -> reg u32 {
  reg u32 a0 a1;
  inline bool gt le;

  a0, a1 = __decompose_a0a1(a, q);

  if (hint != 0) {
   //    ?{">s" = gt, "<=s" = le} = #CMP(a0, 0);
   gt = (a0 >s 0);
   le = (a0 <=s 0);

   if (gt) {
      a1 += 1;
   }
   if (le) {
     a1 -=1 ;
   }

    a1 &= 15;
  }
  return a1;
}
