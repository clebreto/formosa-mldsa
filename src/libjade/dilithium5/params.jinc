
param int N = 256;
param int TAU = 60;
param int iQ = 8380417;
u32 Q = iQ;

param int ETA = 2;

param int POLYETA_PACKEDBYTES = 96;


param int PQC_SHAKECTX_BYTES = 25;
param int SEEDBYTES = 32;

param int SHAKE256_RATE = 136;

param int D = 13;

param int iGAMMA2 = ((iQ-1)/32);
u32 GAMMA2 = iGAMMA2;


u32 MINUS_Q = -iQ; // this should be -Q
u32 MINUS_GAMMA2 = -iGAMMA2;


inline fn __Q() -> reg u32 {
 // Q = 8380417 = 11 1111 1111 0000 0000 0000 1
  reg u32 q;
  q = 0x3FF;
  q <<= 13;
  q |= 1;
  return q;
}

inline fn __MINUS_Q() -> reg u32 {
 // -Q = -8380417 = 1 1111 1111 000 0000 000 1 1111 1111 1111
  reg u32 mq, q;
  q = __Q();
  mq = -q;
  return mq;
}


/* ********************************************************************** */
/* Helper functions for the test and export function                      */

inline fn __mem_to_poly (reg u32 p) -> stack u32[N] {
  stack u32[N] a;
  reg ptr u32[N] pa;
  reg u32 ai i;
  pa = a;
  i = 0;
  while (i < N) { 
    ai = (u32)[p + 4 * i];
    pa[(int) i] = ai;
    i += 1;
  }
  a = pa;
  return a;
}

inline fn __poly_to_mem (stack u32[N] a, reg u32 p) {
  reg u32 ai i;
  reg ptr u32[N] pa;
  i = 0;
  pa = a;
  while (i < N) { 
    ai = pa[(int) i];
    (u32)[p + 4 * i] = ai;
    i += 1;
  } 
}

inline fn __state_to_mem (reg ptr u32[25*2] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;

  while (i < 25*2) {
    ai = pa[(int) i];
    (u32)[p + 4 * i] = ai;
    i += 1;
  }
}

inline fn __buf_to_mem (reg ptr u8[SHAKE256_RATE] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;

  while (i < SHAKE256_RATE) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __mem_to_array (reg u32 p) -> stack u8[SEEDBYTES] {
  stack u8[SEEDBYTES] a;
  reg ptr u8[SEEDBYTES] pa;
  reg u32 i;
  reg u32 ai;

  pa = a;
  i = 0;
  while (i < SEEDBYTES  / 4) { 
    ai = [p + 4*i];
    pa[u32 (int) i] = ai;
    i += 1;
  }
  inline int j;
  reg u8 ai8;
  p = p + (i << 2);
  for j = 0 to SEEDBYTES %4 {
    ai8 = [p + i];
    pa[(int) i] = ai8;
  } 
  a = pa;
  return a;
}

inline fn __mem_to_polyeta (reg u32 p) -> stack u8[POLYETA_PACKEDBYTES] {
  stack u8[POLYETA_PACKEDBYTES] a;
  reg ptr u8[POLYETA_PACKEDBYTES] pa;
  reg u32 ai i;
  pa = a;
  i = 0;
  while (i < POLYETA_PACKEDBYTES) {
    ai = (u32)[p + i];
    pa[(int) i] = ai;
    i += 1;
  }
  a = pa;
  return a;
}

inline fn __polyeta_to_mem (reg ptr u8[POLYETA_PACKEDBYTES] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;

  while (i < POLYETA_PACKEDBYTES) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}



