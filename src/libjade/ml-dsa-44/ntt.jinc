
/*************************************************
* Name:        JASMIN_MLDSA44_ntt
*
* Description: Forward NTT, in-place. No modular reduction is performed after
*              additions or subtractions. Output vector is in bitreversed order.
*
* Arguments:   - uint32_t p[N]: input/output coefficient array
**************************************************/
/*
void JASMIN_MLDSA44_ntt(int32_t a[N]) {
    unsigned int len, start, j, k;
    int32_t zeta, t;

    k = 0;
    for (len = 128; len > 0; len >>= 1) {
        for (start = 0; start < N; start = j + len) {
            zeta = zetas[++k];
            for (j = start; j < start + len; ++j) {
                t = JASMIN_MLDSA44_montgomery_reduce((int64_t)zeta * a[j + len]);
                a[j + len] = a[j] - t;
                a[j] = a[j] + t;
            }
        }
    }
}
*/

inline fn __mul_montgomery_reduce_8380417(reg u32 x, reg u32 y) -> reg u32 {
  reg u32 aux_hi aux_lo t;

  aux_lo, aux_hi = __smull(x, y, aux_lo, aux_hi);
  t = __montgomery_reduce_8380417(aux_lo, aux_hi);

  return t;

}

inline fn __ntt(reg ptr u32[N] a) -> reg ptr u32[N] {

  reg u32 len start j k;
  reg u32 zeta t;

  reg ptr u32[N] zetas;  
  reg u32 start_len j_len aj aj_len;
  k = 0;
   /* for (len = 128; len > 0; len >>= 1) { */
   len = 128;
   while {
     start = 0;
     /* for (start = 0; start < N; start = j + len) */
     while {
       /* zeta = zetas[++k]; */
       k += 1;
       zetas = ZETAS;
       zeta = zetas[(int)k];
       /* for (j = start; j < start + len; ++j)  */
       j = start;
       start_len = start + len;
       j_len = start_len;
       /* invariant j_len = j + len */
       while {
         /* t = JASMIN_MLDSA44_montgomery_reduce((int64_t)zeta * a[j + len]); */
         aj_len = a[(int) j_len];
         t = __mul_montgomery_reduce_8380417(zeta, aj_len);
         /* a[j + len] = a[j] - t; */
         aj = a[(int) j];
         aj_len = aj - t;
         a[(int) j_len] = aj_len;
         /* a[j] = a[j] + t; */
         aj = aj + t;
         a[(int) j] = aj;
         j += 1;
         j_len += 1;
       } (j < start_len)
       start = j_len;  // start = start + 2 * len
     } (start < N)
     //?{zf}, len = #LSRS(len, 1);
     len = len >> 1;
   } (len != 0)
  
  return a;
}

fn _ntt(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __ntt(a);
  return a;
} 

/*************************************************
* Name:        JASMIN_MLDSA44_invntt_tomont
*
* Description: Inverse NTT and multiplication by Montgomery factor 2^32.
*              In-place. No modular reductions after additions or
*              subtractions; input coefficients need to be smaller than
*              Q in absolute value. Output coefficient are smaller than Q in
*              absolute value.
*
* Arguments:   - uint32_t p[N]: input/output coefficient array
**************************************************/
/*
void JASMIN_MLDSA44_invntt_tomont(int32_t a[N]) {
    unsigned int start, len, j, k;
    int32_t t, zeta;
    const int32_t f = 41978; // mont^2/256

    k = 256;
    for (len = 1; len < N; len <<= 1) {
        for (start = 0; start < N; start = j + len) {
            zeta = -zetas[--k];
            for (j = start; j < start + len; ++j) {
                t = a[j];
                a[j] = t + a[j + len];
                a[j + len] = t - a[j + len];
                a[j + len] = JASMIN_MLDSA44_montgomery_reduce((int64_t)zeta * a[j + len]);
            }
        }
    }

    for (j = 0; j < N; ++j) {
        a[j] = JASMIN_MLDSA44_montgomery_reduce((int64_t)f * a[j]);
    }
}
*/

inline fn __invntt_tomont(reg ptr u32[N] a) -> reg ptr u32[N] {

  reg u32 len start j k;
  reg u32 zeta t;

  reg ptr u32[N] zetas;  
  reg u32 start_len j_len aj aj_len;

  k = 256;
  /* for (len = 1; len < N; len <<= 1) */
  len = 1; 
  while {
    /* for (start = 0; start < N; start = j + len) */
    start = 0;
    while {
      /* zeta = -zetas[--k]; */
      k -= 1;
      zetas = ZETAS;
      zeta = zetas[(int)k]; zeta = -zeta;
      /* for (j = start; j < start + len; ++j)  */
      j = start;
      start_len = start + len;
      j_len = start_len;
      /* invariant j_len = j + len */
      while {
        /* t = a[j]; */
        t = a[(int) j];
        /* a[j] = t + a[j + len]; */
        aj_len = a[(int) j_len]; aj = t + aj_len; a[(int) j] = aj;
        /* a[j + len] = t - a[j + len]; */
        aj_len = t - aj_len;
        /* a[j + len] = JASMIN_MLDSA44_montgomery_reduce((int64_t)zeta * a[j + len]); */
        aj_len = __mul_montgomery_reduce_8380417(zeta, aj_len);
        a[(int) j_len] = aj_len;
        j += 1;
        j_len += 1;
      } (j < start_len)
      start = j_len;  // start = start + 2 * len
    }  (start < N)
    len <<= 1; 
    
  } (len < N)

  reg u32 f; 
  f = 41978; // mont^2/256
  
  /* for (j = 0; j < N; ++j) */
  j = 0;
  while {
    /*   a[j] = JASMIN_MLDSA44_montgomery_reduce((int64_t)f * a[j]); */
    aj = a[(int) j];
    aj = __mul_montgomery_reduce_8380417(f, aj);
    a[(int) j] = aj;
  
    j+=1;
  } (j < N)

  return a;
}

fn _invntt_tomont(reg ptr u32[N] a) -> reg ptr u32[N] {
  a = __invntt_tomont(a);
  return a;
}
