// Should we move this elsewhere ?
param int D = 13;

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_power2round
*
* Description: For finite field element a, compute a0, a1 such that
*              a mod^+ Q = a1*2^D + a0 with -2^{D-1} < a0 <= 2^{D-1}.
*              Assumes a to be standard representative.
*
* Arguments:   - int32_t a: input element
*              - int32_t *a0: pointer to output element a0
*
* Returns a0, a1.
**************************************************/

inline fn __power2round_a0a1(reg u32 a) -> reg u32, reg u32 
{
  reg u32 a0 a1 a2;
  a1 = a + ((1 << (D - 1)) - 1); 
  a1 = a1 >> D;
  a0 = a - (a1 << D);
  return (a0, a1);     
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_power2round
*
* Description: For finite field element a, compute a0, a1 such that
*              a mod^+ Q = a1*2^D + a0 with -2^{D-1} < a0 <= 2^{D-1}.
*              Assumes a to be standard representative.
*
* Arguments:   - int32_t a: input element
*              - int32_t *a0: pointer to output element a0
*
* Returns a1.
**************************************************/
inline fn __power2round(reg ptr u32[1] p, reg u32 a) -> reg ptr u32[1], reg u32 
{     
  reg u32 a0 a1;
  (a0, a1) = __power2round_a0a1(a);
  p[0] = a0;
  return (p, a1);
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_decompose
*
* Description: For finite field element a, compute high and low bits a0, a1 such
*              that a mod^+ Q = a1*ALPHA + a0 with -ALPHA/2 < a0 <= ALPHA/2 except
*              if a1 = (Q-1)/ALPHA where we set a1 = 0 and
*              -ALPHA/2 <= a0 = a mod^+ Q - Q < 0. Assumes a to be standard
*              representative.
*
* Arguments:   - int32_t a: input element
*              - int32_t *a0: pointer to output element a0
*
* Returns a1.
**************************************************/

// precondition q = Q
inline fn decompose_a0a1(reg u32 a q) -> reg u32, reg u32
{
  reg u32 a0 a1 aux q;
  
  /* a1  = (a + 127) >> 7; */
  a1 =  a + 127;
  a1 >>s= 7;
  
  /* a1  = (a1 * 1025 + (1 << 21)) >> 22;
     a1 &= 15; */
  
  aux = a1 + (a1 << 10); // aux = a1 * 1025;
  aux += (1 << 21);
  a1 = #UBFX(aux, 22, 4);
  
  /* *a0  = a - a1 * 2 * GAMMA2; */
  /* - 2*GAMMA2 = (1 - 2 ^ 10) * 2^9 */
  aux = a1 - (a1 << 10);
  a0 = a + (aux << 9);  
  
  /* *a0 -= (((Q - 1) / 2 - *a0) >> 31) & Q; */
  /* (Q - 1) / 2 = 1023 * 2^12 */
  aux = 1023;
  aux = #RSB(a0, aux << 12); // (Q - 1) / 2 - *a0
  aux = q & (aux >>s 31);
  a0 -= aux;
  
  return a0, a1;
}

