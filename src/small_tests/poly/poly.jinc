
// note: this file expects params.jinc

from Dilithium require "reduce.jinc"
from Dilithium require "rounding.jinc"
from Dilithium require "ntt.jinc"

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_reduce
*
* Description: Inplace reduction of all coefficients of polynomial to
*              representative in [-6283009,6283007].
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N]
{
  reg u32 i coeff;

  i = 0;
  while(i < N)
  {
    coeff = a[(int) i];
    coeff = reduce32(coeff);
    a[(int) i] = coeff;

    i += 1;
  }

  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_caddq
*
* Description: For all coefficients of in/out polynomial add Q if
*              coefficient is negative.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
  reg u32 i coeff;

  i = 0;
  while(i < N)
  {
    coeff = a[(int) i];
    coeff = caddq(coeff);
    a[(int) i] = coeff;

    i += 1;
  }

  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_add
*
* Description: Add polynomials. No modular reduction is performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first summand
*              - const poly *b: pointer to second summand
**************************************************/

inline fn __poly_add_inplace(reg ptr u32[N] a b) -> reg ptr u32[N]
{
  reg u32 i coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_a = coeff_a + coeff_b;
    a[(int) i] = coeff_a;

    i += 1;
  }

  return a;
}

inline fn __poly_add(reg ptr u32[N] r a b) -> reg ptr u32[N]
{
  reg u32 i coeff_r coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_r = coeff_a + coeff_b;
    r[(int) i] = coeff_r;

    i += 1;
  }

  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_sub
*
* Description: Subtract polynomials. No modular reduction is
*              performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial to be
*                               subtraced from first input polynomial
**************************************************/
inline fn __poly_sub(reg ptr u32[N] r a b) -> reg ptr u32[N]
{
  reg u32 i coeff_r coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_r = coeff_a - coeff_b;
    r[(int) i] = coeff_r;

    i += 1;
  }

  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_shiftl
*
* Description: Multiply polynomial by 2^D without modular reduction. Assumes
*              input coefficients to be less than 2^{31-D} in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/

inline fn __poly_shiftl(reg ptr u32[N] a) -> reg ptr u32[N]
{
  reg u32 i coeff_a;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_a <<= D;
    a[(int) i] = coeff_a;

    i += 1;
  }

  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_power2round
*
* Description: For all coefficients c of the input polynomial,
*              compute c0, c1 such that c mod Q = c1*2^D + c0
*              with -2^{D-1} < c0 <= 2^{D-1}. Assumes coefficients to be
*              standard representatives.
*
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
*              - poly *a0: pointer to output polynomial with coefficients c0
*              - const poly *a: pointer to input polynomial
**************************************************/

inline fn __poly_power2round(reg ptr u32[N] a1 a0, const reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N]
{

  reg u32 i coeff_a coeff_a0 coeff_a1;

  i = 0;
  while(i < N) 
  {
    coeff_a = a[(int) i];
    coeff_a0, coeff_a1 = __power2round_a0a1(coeff_a);
    a0[(int) i] = coeff_a0;
    a1[(int) i] = coeff_a1;
    i += 1;
  }
  return a1, a0;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_decompose
*
* Description: For all coefficients c of the input polynomial,
*              compute high and low bits c0, c1 such c mod Q = c1*ALPHA + c0
*              with -ALPHA/2 < c0 <= ALPHA/2 except c1 = (Q-1)/ALPHA where we
*              set c1 = 0 and -ALPHA/2 <= c0 = c mod Q - Q < 0.
*              Assumes coefficients to be standard representatives.
*
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
*              - poly *a0: pointer to output polynomial with coefficients c0
*              - const poly *a: pointer to input polynomial
**************************************************/
inline __poly_decompose(reg ptr u32[N] a1 a0, const reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N]
{

  reg u32 i coeff_a coeff_a0 coeff_a1 q;

  i = 0;
  q = Q;
  while(i < N) 
  {
    coeff_a = a[(int) i];
    coeff_a0, coeff_a1 = __decompose_a0a1(coeff_a, q);
    a0[(int) i] = coeff_a0;
    a1[(int) i] = coeff_a1;
    i += 1;
  }
  return a1, a0;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_ntt
*
* Description: Inplace forward NTT. Coefficients can grow by
*              8*Q in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/

inline fn __poly_ntt(reg ptr u32[N] a) -> reg ptr u32[N] {

    a = __ntt(a);
    return a;
}


/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_pointwise_montgomery
*
* Description: Pointwise multiplication of polynomials in NTT domain
*              representation and multiplication of resulting polynomial
*              by 2^{-32}.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial
**************************************************/
inline fn __poly_pointwise_montgomery(reg ptr u32[N] c, const reg ptr u32[N] a, const reg ptr u32[N]b) ->
       reg ptr u32[N] 
{

  reg u32 i coeff_c coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    /* c->coeffs[i] = PQCLEAN_DILITHIUM5_CLEAN_montgomery_reduce((int64_t)a->coeffs[i] * b->coeffs[i]); */
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    aux_hi, aux_lo = #SMULL(coeff_a, coeff_b);
    coeff_c = __montgomery_reduce_8380417(aux_lo, aux_hi);
    c[(int) i] = coeff_c;

    i += 1;
  }

  return r;
}

/* FIXME move this in param */
param int OMEGA = 75;
param int K = 8;
param int POLYETA_PACKEDBYTES = 96;
param int ETA = 2;

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyeta_unpack
*
* Description: Unpack polynomial with coefficients in [-ETA,ETA].
*
* Arguments:   - poly *r: pointer to output polynomial
*              - const uint8_t *a: byte array with bit-packed polynomial
**************************************************/
/*
inline fn __polyeta_unpack(reg ptr u32[N] r, reg ptr u8[POLYETA_PACKEDBYTES] a) {
  reg u32 i i0 i1 i2 a0 a1 a2;
  i = 0;

  while {
    i0 = i + i << 1; // i_0 = 3 * i + 0
    a0 = (32u) a[i0];
    i1 = i_0 + 1;
    a1 = (32u) a[i1];
    i2 = i_1 + 1;
    a2 = (32u) a[i2];

    i8 = i << 3;  // i8 = i*8
    /* r->coeffs[8 * i + 0] =  (a[3 * i + 0] >> 0) & 7;
       r->coeffs[8 * i + 0] = ETA - r->coeffs[8 * i + 0]; */
    aux = ETA - a0; r[i8] = a0;

    /* r->coeffs[8 * i + 1] =  (a[3 * i + 0] >> 3) & 7;
       r->coeffs[8 * i + 1] = ETA - r->coeffs[8 * i + 1]; */
    i8 += 1;
    aux = a0 >> 3; aux = ETA

    aux = a0 >> 3; aux = ETA - aux;  


    r


    i += 1;
  } (i < N / 8)
  return r;
}
  
  for (i = 0; i < N / 8; ++i) {
     
      r->coeffs[8 * i + 2] = ((a[3 * i + 0] >> 6) | (a[3 * i + 1] << 2)) & 7;
      r->coeffs[8 * i + 3] =  (a[3 * i + 1] >> 1) & 7;
      r->coeffs[8 * i + 4] =  (a[3 * i + 1] >> 4) & 7;
      r->coeffs[8 * i + 5] = ((a[3 * i + 1] >> 7) | (a[3 * i + 2] << 1)) & 7;
      r->coeffs[8 * i + 6] =  (a[3 * i + 2] >> 2) & 7;
      r->coeffs[8 * i + 7] =  (a[3 * i + 2] >> 5) & 7;
  
      
      r->coeffs[8 * i + 2] = ETA - r->coeffs[8 * i + 2];
      r->coeffs[8 * i + 3] = ETA - r->coeffs[8 * i + 3];
      r->coeffs[8 * i + 4] = ETA - r->coeffs[8 * i + 4];
      r->coeffs[8 * i + 5] = ETA - r->coeffs[8 * i + 5];
      r->coeffs[8 * i + 6] = ETA - r->coeffs[8 * i + 6];
      r->coeffs[8 * i + 7] = ETA - r->coeffs[8 * i + 7];
  }
  
  DBENCH_STOP(*tpack);
}
*/
/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_polyeta_pack
*
* Description: Bit-pack polynomial with coefficients in [-ETA,ETA].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYETA_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/

inline fn __polyeta_pack(reg ptr u8[POLYETA_PACKEDBYTES] r, const reg ptr u32[N] a) 
  -> reg ptr u8[POLYETA_PACKEDBYTES]
{
  reg u32 i i_0 i_1 i_2 aux ;
  inline int j;
  reg u8[8] t;
  
  i = 0;
  while {
    i8j = i << 3;

    /*  
     t[0] = (uint8_t) (ETA - a->coeffs[8 * i + 0]);
     t[1] = (uint8_t) (ETA - a->coeffs[8 * i + 1]);
     t[2] = (uint8_t) (ETA - a->coeffs[8 * i + 2]);
     r[3 * i + 0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
    */

    for j = 0 to 3 {
      // FIXME do a function for this 
      coef = a[i8j]; 
      t[j] = ETA - coef; 
      i8j += 1;
    }
    aux  = t[0] >> 0;  // unsign shift 
    aux |= t[1] << 3;
    aux |= t[2] << 6;
    
    i_0 = i + i << 1; // i_0 = 3 * i + 0
    r[i_0] = aux;  // This perform the cast to an u8

    /* 
    t[3] = (uint8_t) (ETA - a->coeffs[8 * i + 3]);
    t[4] = (uint8_t) (ETA - a->coeffs[8 * i + 4]);
    t[5] = (uint8_t) (ETA - a->coeffs[8 * i + 5]);
    r[3 * i + 1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
    */ 
    
    for j = 3 to 6 {
      coef = a[i8j]; 
      t[j] = ETA - coef; 
      i8j += 1;
    }     
 
    aux  = t[2] >> 0;  // unsign shift 
    aux |= t[3] << 1;
    aux |= t[4] << 4;
    aux |= t[5] << 7;
    i_1 = i_0 + 1;         // i_1 = 3 * i + 1;
    r[i_1] = aux;

    /*
    t[6] = (uint8_t) (ETA - a->coeffs[8 * i + 6]);
    t[7] = (uint8_t) (ETA - a->coeffs[8 * i + 7]);
    r[3 * i + 2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
    */ 
    for j = 6 to 8 {
      coef = a[i8j]; 
      t[j] = ETA - coef; 
      i8j += 1;
    } 
    aux  = t[5] >> 1;
    aux |= t[6] << 2;
    aux |= t[7] << 5;
    i_2 = i_0 + 2;         // i_2 = 3 * i + 2;
    r[i_2] = aux;
    
    i += 1;
  } (i < N / 8)      
  return r;
}


/*
// TODO list

void PQCLEAN_DILITHIUM5_CLEAN_poly_invntt_tomont(poly *a) {


unsigned int PQCLEAN_DILITHIUM5_CLEAN_poly_make_hint(poly *h, const poly *a0, const poly *a1) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_use_hint(poly *b, const poly *a, const poly *h) {
int PQCLEAN_DILITHIUM5_CLEAN_poly_chknorm(const poly *a, int32_t B) {
static unsigned int rej_uniform(int32_t *a, unsigned int len, const uint8_t *buf, unsigned int buflen) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_uniform(poly *a, const uint8_t seed[SEEDBYTES], uint16_t nonce) {
static unsigned int rej_eta(int32_t *a, unsigned int len, const uint8_t *buf, unsigned int buflen) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_uniform_eta(poly *a, const uint8_t seed[CRHBYTES], uint16_t nonce) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_uniform_gamma1(poly *a, const uint8_t seed[CRHBYTES], uint16_t nonce) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_challenge(poly *c, const uint8_t seed[SEEDBYTES]) {
void PQCLEAN_DILITHIUM5_CLEAN_polyeta_unpack(poly *r, const uint8_t *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyt1_pack(uint8_t *r, const poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyt1_unpack(poly *r, const uint8_t *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyt0_pack(uint8_t *r, const poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyt0_unpack(poly *r, const uint8_t *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyz_pack(uint8_t *r, const poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyz_unpack(poly *r, const uint8_t *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyw1_pack(uint8_t *r, const poly *a) {
*/


