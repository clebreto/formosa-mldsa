
// note: this file expects params.jinc

from Dilithium require "reduce.jinc"
from Dilithium require "rounding.jinc"

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_reduce
*
* Description: Inplace reduction of all coefficients of polynomial to
*              representative in [-6283009,6283007].
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N]
{
  reg u32 i coeff;

  i = 0;
  while(i < N)
  {
    coeff = a[(int) i];
    coeff = reduce32(coeff);
    a[(int) i] = coeff;

    i += 1;
  }

  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_caddq
*
* Description: For all coefficients of in/out polynomial add Q if
*              coefficient is negative.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/
inline fn __poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
  reg u32 i coeff;

  i = 0;
  while(i < N)
  {
    coeff = a[(int) i];
    coeff = caddq(coeff);
    a[(int) i] = coeff;

    i += 1;
  }

  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_add
*
* Description: Add polynomials. No modular reduction is performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first summand
*              - const poly *b: pointer to second summand
**************************************************/

inline fn __poly_add_inplace(reg ptr u32[N] a b) -> reg ptr u32[N]
{
  reg u32 i coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_a = coeff_a + coeff_b;
    a[(int) i] = coeff_a;

    i += 1;
  }

  return a;
}

inline fn __poly_add(reg ptr u32[N] r a b) -> reg ptr u32[N]
{
  reg u32 i coeff_r coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_r = coeff_a + coeff_b;
    r[(int) i] = coeff_r;

    i += 1;
  }

  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_sub
*
* Description: Subtract polynomials. No modular reduction is
*              performed.
*
* Arguments:   - poly *c: pointer to output polynomial
*              - const poly *a: pointer to first input polynomial
*              - const poly *b: pointer to second input polynomial to be
*                               subtraced from first input polynomial
**************************************************/
inline fn __poly_sub(reg ptr u32[N] r a b) -> reg ptr u32[N]
{
  reg u32 i coeff_r coeff_a coeff_b;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_b = b[(int) i];
    coeff_r = coeff_a - coeff_b;
    r[(int) i] = coeff_r;

    i += 1;
  }

  return r;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_shiftl
*
* Description: Multiply polynomial by 2^D without modular reduction. Assumes
*              input coefficients to be less than 2^{31-D} in absolute value.
*
* Arguments:   - poly *a: pointer to input/output polynomial
**************************************************/

inline fn __poly_shiftl(reg ptr u32[N] a) -> reg ptr u32[N]
{
  reg u32 i coeff_a;

  i = 0;
  while(i < N)
  {
    coeff_a = a[(int) i];
    coeff_a <<= D;
    a[(int) i] = coeff_a;

    i += 1;
  }

  return a;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_power2round
*
* Description: For all coefficients c of the input polynomial,
*              compute c0, c1 such that c mod Q = c1*2^D + c0
*              with -2^{D-1} < c0 <= 2^{D-1}. Assumes coefficients to be
*              standard representatives.
*
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
*              - poly *a0: pointer to output polynomial with coefficients c0
*              - const poly *a: pointer to input polynomial
**************************************************/

inline fn __poly_power2round(reg ptr u32[N] a1 a0, const reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N]
{

  reg u32 i coeff_a coeff_a0 coeff_a1;

  i = 0;
  while(i < N) 
  {
    coeff_a = a[(int) i];
    coeff_a0, coeff_a1 = __power2round_a0a1(coeff_a);
    a0[(int) i] = coeff_a0;
    a1[(int) i] = coeff_a1;
    i += 1;
  }
  return a1, a0;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_poly_decompose
*
* Description: For all coefficients c of the input polynomial,
*              compute high and low bits c0, c1 such c mod Q = c1*ALPHA + c0
*              with -ALPHA/2 < c0 <= ALPHA/2 except c1 = (Q-1)/ALPHA where we
*              set c1 = 0 and -ALPHA/2 <= c0 = c mod Q - Q < 0.
*              Assumes coefficients to be standard representatives.
*
* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
*              - poly *a0: pointer to output polynomial with coefficients c0
*              - const poly *a: pointer to input polynomial
**************************************************/
inline __poly_decompose(reg ptr u32[N] a1 a0, const reg ptr u32[N] a) -> reg ptr u32[N], reg ptr u32[N]
{

  reg u32 i coeff_a coeff_a0 coeff_a1 q;

  i = 0;
  q = Q;
  while(i < N) 
  {
    coeff_a = a[(int) i];
    coeff_a0, coeff_a1 = __decompose_a0a1(coeff_a, q);
    a0[(int) i] = coeff_a0;
    a1[(int) i] = coeff_a1;
    i += 1;
  }
  return a1, a0;
}

/*
// TODO list
void PQCLEAN_DILITHIUM5_CLEAN_poly_ntt(poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_invntt_tomont(poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_pointwise_montgomery(poly *c, const poly *a, const poly *b) {

unsigned int PQCLEAN_DILITHIUM5_CLEAN_poly_make_hint(poly *h, const poly *a0, const poly *a1) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_use_hint(poly *b, const poly *a, const poly *h) {
int PQCLEAN_DILITHIUM5_CLEAN_poly_chknorm(const poly *a, int32_t B) {
static unsigned int rej_uniform(int32_t *a, unsigned int len, const uint8_t *buf, unsigned int buflen) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_uniform(poly *a, const uint8_t seed[SEEDBYTES], uint16_t nonce) {
static unsigned int rej_eta(int32_t *a, unsigned int len, const uint8_t *buf, unsigned int buflen) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_uniform_eta(poly *a, const uint8_t seed[CRHBYTES], uint16_t nonce) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_uniform_gamma1(poly *a, const uint8_t seed[CRHBYTES], uint16_t nonce) {
void PQCLEAN_DILITHIUM5_CLEAN_poly_challenge(poly *c, const uint8_t seed[SEEDBYTES]) {
void PQCLEAN_DILITHIUM5_CLEAN_polyeta_pack(uint8_t *r, const poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyeta_unpack(poly *r, const uint8_t *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyt1_pack(uint8_t *r, const poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyt1_unpack(poly *r, const uint8_t *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyt0_pack(uint8_t *r, const poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyt0_unpack(poly *r, const uint8_t *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyz_pack(uint8_t *r, const poly *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyz_unpack(poly *r, const uint8_t *a) {
void PQCLEAN_DILITHIUM5_CLEAN_polyw1_pack(uint8_t *r, const poly *a) {
*/


